## 1 图论基本概述

由点（节点Vertex）和边（边Edge）组成的数据结构。

交通运输、社交网络、互联网、脑区活动、程序状态执行

### 1.1 图的分类

1 图可分为无向图（Undirected Graph）和有向图（Directed Graph）。有向图就是一个节点通往另外一个节点是具有方向性的，可视化来看就是，边具有箭头属性。

无向图可以看作一种特殊的有向图。

2 无权图（Unweighted Graph）和有权图（Weighted Graph）。就是连接点和点的边有没有一个权值和他对应。比如：有权图，点表示地方，边表示两个地方的距离，边的权值就是距离值。

### 1.2 其他概念

**图的连通性**

图的节点不是全部都是连接在一起的。

**简单图**（Simple Graph）

自环边（self-loop）自己指向自己的边

平行边（parallel-edges）两个节点间有多条边连接（就像是两个地方可以有多种路径可以互通）

简单图是没有自环边和平行边的图。

## 2 图的表示

### 2.1 邻接矩阵 + 邻接表

**邻接矩阵（Adjacency Matrix）**

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\图论\二位数组-邻接矩阵.jpg" alt="二位数组-邻接矩阵" style="zoom:30%;" />

用一个**二维数组来表示一个无向图**，两个节点彼此的连接关系，0表示未连接，1表示连接。这样的一个二维数组是关于斜对角线对称的。

用二维数组也可以表示一个有向图，比如0节点指向1节点，那么arr[0] [1]为1，但是arr[1] [0]为0。

**邻接表（Adjacency Lists）**

每一行相当于一个链表：

0   1

1   0 2 3

2   1 3

3   1 2

只保存当前节点相连的节点，相较于邻接矩阵，节省了存储空间。

邻接表适合表示稀疏图（Sparse Graph），邻接矩阵适合表示稠密图（Dense Graph）

完全图 就是所有的点和所有的点都有连接。

#### 2.1.1 邻接矩阵

邻接矩阵实现稠密图

```c++
class DenseGraph{
private:
    int n, m; //n是节点个数，m是边的个数
    bool directed; //有向图无向图标志
    vector<vector<bool>> g; //邻接矩阵（二维数组）
public:
    DenseGraph(int n, bool directed){
        this->n = n;
        this->m = 0;
        this->directed = directed;
        for(int i = 0; i < n; i ++){
            g.push_back( vector<bool>(n, false) ); //每行都是n个false
        }
    }
    ~DenseGraph(){} //析构函数
    int V(){ return n; }
    int E(){ return m; }
    void addEdge(int v, int w){ //添加边 就是将两个节点进行连接操作
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        //不需要担心自环边的问题
        //为了排除平行边的问题，事先判断
        if( containEdge(v, w) ) return;
        g[v][w] = true;
        if( !directed ){ //无向图
            g[w][v] = true;
        }
        m ++;
    }
    bool containEdge(int v, int w){
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        return g[v][w];
    }
}
```

#### 2.1.2 邻接表

邻接表实现稀疏图

```c++
class SparseGraph{
private:
    int n, m;
    bool directed;
    vector<vector<int>> g; //因为一行相当于一个表，存储的是和这个节点相连的节点编号，所以此处的vector是int类型。
public:
    SparseGraph(int n, bool directed){
        this->n = n;
        this->m = 0;
        this->directed = directed;
        for(int i = 0; i < n; i ++){
            g.push_back( vector<int>() ); //默认放进来的是空的
        }
    }
    ~SparseGraph(){}
    int V(){ return n; }
    int E(){ return m; }
    void addEdge(int v, int w){
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        //若想解决平行边的问题，就需要先判断是否该边已存在，这样添加边的时间复杂度也回增加到O(n)，所以这也是邻接表可改进的点，即最后一块判断，将重复边删除。
        if(hasEdge(v, w)) return;
        g[v].push_back(w);
        //解决自环边的重复记录问题
        if( v!=w && !direxted){
            g[w].push_back(v);
        }
        m ++;
    }
    //时间复杂度大  是O(n)
    bool hasEdge(int v, int w){
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        for(int i = 0; i < n; i ++){
            if(g[v][i] == w){
                return true;
            }
        }
        return false;
    }
    
}
```

**邻接表优势**：当遍历一个节点的临边时，用邻接矩阵的时间复杂度O(v)因为要遍历一整行，但是用邻接表效率就高了。

### 2.2 遍历某个节点所有的临边

#### 2.2.1 稀疏图遍历

为了使得 vector<> g 不被外部直接访问，而是作为私有属性存在，自定义一个迭代器用于外部访问。

```c++
class SparseGraph{
    ...
    class adjIterator{
    private:
        SparseGraph &G;
        int v;
        int index;
    public:
        adjIterator(SparseGraph &graph, int v):G(graph){ //继承G
            this->v = v;
            this->index = 0;
        } 
        int begin(){
            index = 0;
            if(G.g[v].size())
                return G.g[v][index];
            return -1;
        }
        int next(){
            index ++; //注意先index++
            if(index < G.g[v].size())
                return G.g[v][index];
            return -1;
        }
        bool end(){
            return index >= G.g[v].size();
        }
    }    
}


//测试
for(int v = 0; v < N; v ++){
    cout<<v<<":";
    SparseGraph::adjIterator adj(g1, v);
    for(int w = adj.begin(); !adj.end(); w = adj.next()){
        cout << w << " ";
    }
    cout << endl;
}
```

因为是可以直接获取到w值，所以遍历的时间复杂度为O(V)   V是节点个数

#### 2.2.2 稠密图遍历

也是需要自定义迭代器

它和稀疏图的不同是，这个的底层实现是邻接矩阵，所以遍历某节点所有的临边时，不能从0开始直接根据索引依次得到了，而是要寻找为true的那个位置的节点，因此，起始就是第一个为true的位置，而next就是再寻找下一个为true的位置。

```c++
class DenseGraph{
    ...
    class adjIterator{
    private:
        DenseGraph &G;
        int v;
        int index;
    public:
        adjIterator(DenseGraph &graph, int v):G(graph){
            this->v = v;
            this->index = -1; //注意这个的初始值为-1
        }
        int begin(){ //这个的begin不能从0开始了
            index = -1;
            return next(); //这里不需要判断，因为next里已经隐藏判断了
        }
        int next(){
            for(index += 1; index < G.g[v].size(); index ++){
                if(G.g[v][index])
                    return index; //注意当此时执行return index了，也就说明不会再去执行index ++了，所以下一次进来的时候的index还是此时的index，所以依旧需要先index+=1。
            }
            return -1;
        }
        bool end(){
            return index >= G.g[v].size();
        }
    }
}

//测试
for(int v = 0; v < N; v ++){
    cout << v << ": ";
    DenseGraph::adjIterator adj2(g2, v);
    for(int w = adj2.begin(); !adj2.end(); w = adj2.next()){
        cout << w << " ";
    }
    cout << endl;
}
```

因为邻接矩阵的实现特点，当找next的时候需要遍历行，因为时间复杂度为O(V^2)。

由此可以看出，邻接表实现的稀疏图在遍历某节点的所有相邻边问题上更有优势。

## 3 图的进一步实现

### 3.1 从文件读取图的实现

文件首行存储图的节点数和图的边数，下面的行存储图相连接的节点。通过读取文件内容，生成一个图，将其封装为一个方法类。

因为封装成了一个模板类，所以稀疏图和稠密图的类都需要继承Graph的接口。

```c++
template <typename Graph>
class ReadGraph{
public:
    ReadGraph(Graph &graph, const string &filename){
        ifstream file(filename);
        string line;
        int V, E;
        assert( file.is_open() );
        assert( getline(file, line) );
        stringstream ss(line);
        ss>>V>>E;
        assert( V == graph.V() );
        for(int i = 0; i < E; i ++){
            assert( getline(file, line) );
            stringstream ss(line);
            int a,b;
            ss>>a>>b;
            graph.addEdge(a, b);
        }
    }
}
```

## 4 图的遍历

### 4.1 深度优先遍历 dfs

以求连通分量为例，实现深度优先遍历，这个深度优先遍历也涉及到了一个思想，即**回溯思想**。

使用并查集只能来判断两个节点是否相连，但是使用图论就可以看到两个相连节点的路径是怎么样的。

稀疏图的时间复杂度 O(V+E)   稠密图的时间复杂度 O(V^2)

深度优先遍历算法对有向图依然有效。

```c++
#inndef GRAPH_COMPONENT_H
#define GRAPH_COMPONENT_H

#include <iostream>
#include <cassert>
using namespace std;

template <typename Graph>
class Component{
private:
    Graph &G;
    bool *visited; //记录当前节点被访问的状态
    int ccount; //记录包含几个连通图
    int *ids; //记录是否在一个连通图内
    //深度优先遍历
    void dfs(int v){
        //首先将当前遍历的这个节点的访问状态定为true
        visited[v] = true;
        //然后深度遍历该节点的相邻边
        typename Graph::adjIterator adj(G, v);
        for(int i = adj.begin(); !adj.end(); i = adj.next()){
            if( !visited[i] )
                dfs[i];
        }
    }
public:
    Component(Graph &graph):G(graph){
        visited = new bool[G.V()];
        ids = new int[G.V()];
        ccount = 0;
        for(int i = 0; i < G.V(); i ++){
            visited[i] = false;
            ids[i] = -1; //初始为-1  哪个也不属于
        }
        for(int i = 0; i < G.V(); i ++){
            if( !visited[i] ){
                dfs(i); //深度遍历该节点
                ccount ++; //该节点回溯回来说明此时形成了一个连通图了
            }
        }
    }
    ~Component(){
        delete[] visited;
        delete[] ids;
    }
    int count(){
        return ccount;
    }
    bool isConnected(int v, int w){
        //判断v, w合不合理
        assert( v >= 0 && v < G.V() );
        assert( w >= 0 && w < G.V() );
        return ids[v] == ids[w];
    }
}
```

#### 4.1.1 寻路

此处只是为了获取路径，而不是要求最短路径。

寻路也是通过深度优先遍历实现的。深度优先遍历通过递归实现，**打印路径助栈实现**。

```c++
class Path{
private:
    Graph &G;
    int s;
    bool *visited;
    int *from; //存放到到达前节点的前一个节点
    
    dfs(int s){
        visited[s] = true;
        typename Graph::adjIterator adj(G, v);
        for(int i = adj.begin(); !adj.end(); i = adj.next()){
            if( !visited[i] ){
                from[i] = v;
                dfs(i);
            }
        }
        
    }
public:
    Path(Graph &graph, int s):G(graph){ //:G(graph)是初始化列表  //s是输入起点
        assert( s >= 0 && s < G.V() );
        
        visited = new bool[G.V()];
        from = new int[G.V()];
        for(int i = 0; i < G.V(); i ++){
            visited[i] = false;
            from[i] = -1; //起点位置会一直定义为-1的
        }
        this->s = s;
        
        //寻路算法
        dfs(s);//输入起点
    }
    ~Path(){
        delete[] visited;
        delete[] from;
    }
    bool hasPath(int w){ //w是指的路径的终点，判断有没有这个路径
        //如果w这个节点被访问过，也就是到达过这个w
        return visited[w];
    }
    
    void path(int w, vector<int> &vec){
        stack<int> s;
        int p = w;
        while( p != -1 ){
            s.push(p);
            p = from[p]; //找到当前p的来自的节点，继续找，直到找到起点
        }
        vec.clear();
        while( !s.empty() ){
            vec.push_back( s.top() );
            s.pop();
        }
    }
    
    void showPath(int w){ //打印找到的路径
        vector<int> vec;
        path(w, vec);
        for(int i = 0; i < vec.size(); i ++){
            cout << vec[i];
            if(i == vec.size()-1){
                cout << endl;
            }else{
                cout << "->";
            }
        }
    }
    
}
```

### 4.2 广度优先遍历

广度优先遍历，又称层数优先遍历，就是距离起始点的层数的先后。

根据这种特性，寻找的路径就是最短路径

**应用：求出无权图的最短路径**，广度优先**遍历借助队列实现**。

稀疏图的时间复杂度 O(V+E)   稠密图的时间复杂度 O(V^2)

#### 4.2.1 无权图的最短路径

```c++
template <typename Graph>
class ShortestPath{
private:
    Graph &G;
    int s;
    bool *visited;
    int *from;
    int *ord;
public:
    ShortestPath(Graph &graph, int s):G(graph){
        assert( s >= 0 && s < graph.V() );
        visited = new bool[G.V()];
        from = new int[G.V()];
        ord = new int[G.V()];
        for(int i = 0; i < G.V(); i ++){
            visited[i] = false;
            from[i] = -1;
            ord[i] = -1;
        }
        this->s = s;
        
        //队列实现
        queue<int> q;
        q.push( s );
        visited[s] = true;
        ord[s] = 0; //起点距离起点为0
        
        while( !q.empty() ){
            int v = q.front();
            q.pop();
            typename Graph::adjIterator adj(G, v);
            for(int i = adj.begin(); !adj.end(); i = adj.next()){
                if(!visited[i]){
                    visited[i] = true;
                    q.push(i);
                    from[i] = v;
                    ord[i] = ord[v]+1;
                }
            }
        }

    }
    ~ShortedPath(){
        delete[] visited;
        delete[] from;
        delete[] ord;
    }
    bool hasPath(int w){
        assert( w >= 0 && w < G.V() );
        return visited[w];
    }
    void path(int w, vector<int> &vec){
        assert( w >= 0 && w < G.V() )
        stack<int> ss;
        int p = w;
        while( p != -1 ){
            ss.push(p);
            p = from[p];
        }
        vec.clear();
        while( !ss.empty() ){
            vec.push_back(ss.top());
            ss.pop();
        }
        
    }
    void showPath(int w){
        vector<int> vec;
        path(w, vec);
        for(int i = 0; i < vec.size(); i ++){
            cout << vec[i];
            if( i == vec.size() - 1 ){
                cout << endl;
            }else{
                cout << "->";
            }
        }
    }
    
    int length(int w){
        assert( w >= 0 && w < G.V() );
        return ord[w];
    }
}
```

## 5 带权图

邻接矩阵实现的改变，即把原来的true或false，改成权重值就可以了。

邻接表实现的改变，之前的实现，每个节点后面存放的是与它相邻的节点的索引。此处要改为存储索引和权重两个内容，即将边封装成一个类，类里面包括节点和权重两个属性。

### 5.1 边Edge类设计

（Java）

```java
public class Edge<Weight extends Number && Comparable> implements Comparable<Edge>{ //继续可比较接口
    private int a,b; //a b是两个节点
    private Weight weight; //权重
    //构造函数
    public Edge(int a, int b, Weight weight){
        this.a = a;
        this.b = b;
        this.weight = weight;
    }
    public Edge(Edge<Weight> e){
        this.a = e.a;
        this.b = e.b;
        this.weight = e.weight;
    }
    
    public int v() return a; //返回第一个顶点
    public int w() return b; //返回第二个顶点
    public Weight wt() return weight; //返回权值
    
    //知道一个顶点，得到另一个顶点
    public int other(int x){
        assert x == a || x == b;
        return x == a ? b : a;
    }
    //重载输出
    public String toString(){
        return " " + a + "-" + b + ": " + weight;
    }
    
    //重载比较
    public int compareTo(Edge that){
        if(weight.compareTo(that.w()) < 0){
            return -1;
        }else if(weight.compareTo(that.w()) > 0){
            return +1;
        }else{
            return 0;
        }
    }  
}
```

### 5.2 加权稠密图

（Java）

定义带权图的接口

```java
interface WeightedGraph<Weight extends Number && Comparable>{
    public int V();
    public int E();
    public void addEdge(Edge<Weight> e);
    boolean hasEdge(int v, int w);
    void show();
    public Iterable< Edge<Weight> > adj(int x);
}
```

**注：java.util.Vector**;

Vector类实现了一个可增长的对象数组。向量基本上属于遗留类，但现在它与集合完全兼容。Vector也是迭代器Iterator类型。

> - Vector实现了一个动态数组，这意味着它可以根据需要增长或缩小。像数组一样，它包含可以使用整数索引访问的组件
> - 它们与ArrayList非常相似，但Vector是同步的，并且有一些遗留方法，其中包含集合框架。
> - 它扩展了**AbstractList**并实现了**List**接口。

```java
import java.util.Vector;

public class DenseWeightGraph<Weight expends Number && Comparable> implements WeightedGraph{
    private int n; //节点数
    private int m; //边数
    private boolean directed; //有向图无向图
    private Edge<Weight>[][] g; //图的具体数组，存的是Edge类信息
    
    //构造函数
    public DenseWeightGraph(int n, boolean directed){
        this.n = n;
        this.m = 0;
        this.directed = directed;
        g = new Edge[n][n];
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < n; j ++){
                g[i][j] = null;
            }
        }   
    }
    
    public int V() return n;
    public int E() return m;
    
    public boolean hasEdge(int v, int w){
        assert v >= 0 && v < n;
        assert w >= 0 && w < n;
        return g[v][w] == null;
    }
    
    public void addEdge(Edge<Weight> e){
        assert e.v() >= 0 && e.v() < n;
        assert e.w() >= 0 && e.w() < n;
        int v = e.v();
        int w = e.w();
        if(hasEdge(v, w){
            g[v][w] = null;
            if( !directed ) g[w][v] = null;
        	m --;
        }
        g[v][w] = new Edge(e);
        if(v != w && !directed){
            g[w][v] = new Edge(e);
        }   
        m ++;       
    }
           
    public void show(){
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < n; j ++){
                if(g[i][j] != null){
                    System.out.println(g[i][j].wt() + "\t");
                }else{
                    System.out.println("NULL\t");
                }
            }
            System.out.println();
        }
    }   
    //遍历    
    //返回图中一个节点的所有临边       
    // 由于java使用引用机制，返回一个Vector不会带来额外开销
    public Iterator<Edge<Weight>> adj(int v){
        assert v >= 0 && v < n;
        Vector<Edge<Weight>> adjV = new Vector<>();
        for(int i = 0; i < n; i ++){
            if( g[v][i] != null ){
                adjV.add( g[v][i] ); //存的都是v指向i的边
            }
        }
        return adjV;
    }      
}
```



### 5.3 加权稀疏图

（Java）

```java
import java.util.Vector;

public class SparseWeightGraph<Weight extends Number && Comparable> implements WeightedGraph{
    private int n; //节点数
    private int m; //边数
    private boolean directed; //有向图无向图
    private Vector<Edge<Weight>>[] g; //图的信息存储 用vector是因为 他不再是个固定大小的二维数组了。
    
    public SparseWeightGraph(int n, boolean directed){
        this.n = n;
        this.m = 0;
        this.directed = directed;
        for(int i = 0; i < n; i ++){ //n个节点  则数组包括n个Vector
            g[i] = new Vector<Edge<Weight>>();
        }
    }
    public int V() return n;
    public int E() return m;
    
    public hasEdge(int v, int w){
        assert v >= 0 && v < n;
        assert w >= 0 && w < n;
        for(int i = 0; i < g[v].size(); i ++){
            if(g[v].get(i).other(v) == w){
                return true;
            }
        }
        return false;
    }
    
    public void addEdge(Edge<Weight> e){
        int v = e.v();
        int w = e.w();
        assert v >= 0 && v < n;
        assert w >= 0 && w < n;
        //此处程序 允许平行边存在
        g[v].add(new Edge(e));
        if( v!= w && !directed){
            g[w].add(new Edge(e));
        }
        m ++;
    }
    
    public void show(){
        for(int i = 0; i < n; i ++){
            System.out.print("vertex " + i + ":\t");
            for(int j = 0; j < g[i].size(); j ++){
                Edge e = g[i].get(j);
                System.out.print("(to:" + e.other(i) + ", wt:" + e.wt() + ")\t");
            }
            System.out.println();
        }
    }
    
    public Iterator<Edge<Weight>> adj(int v){
        assert v >= 0 && v < n;
        return g[v]; //这存的也是v指向其他点的边
    }
}
```

### 5.4 从文件中读取带权图

由于文件格式的限制，此处程序实现的权重值只能是double类型。

**注意：import java.util.Locale;**

（Java）

```java
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Scanner;
import java.util.Locale;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class ReadWeightedGraph{
    private Scanner scanner;
    public ReadWeightedGraph(WeightedGraph<Double> graph, String filename){
        readFile(filename);
        try{
            //读取节点数
            int V = scanner.nextInt();
            if (V < 0)
                throw new IllegalArgumentException("number of vertices in a Graph must be nonnegative");
            assert V == graph.V();
            //读取边数
            int E = scanner.nextInt();
            if (E < 0)
                throw new IllegalArgumentException("number of edges in a Graph must be nonnegative");
            //读取所有边+节点信息
            for(int i = 0; i < E; i ++){
                int v = scanner.nextInt();
                int w = scanner.nextInt();
                Double weight = scanner.nextDouble();
                assert v >= 0 && v < V;
                assert w >= 0 && w < V;
                graph.addEdge(new Edge<Double>(v, w, weight));
            }
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read an 'int' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read an 'int' value from input stream, but there are no more tokens available");
        }
    }
    //文件读取
    private void readFile(String filename){
        assert filename != null;
        try{
            File file = new File(filename);
            if(file.exists()){
                FileInputStream fis = new FileInputStream(file);
                scanner = new Scanner(new BufferedInputStream(fis), "UTF-8");
                scanner.useLocale(locale.ENGLISH);
            }
        }catch (IOException ioe){
            throw new IllegalArgumentException("Couldn't open " + filename + " file" );
        }
    }
}
```

## 6 最小生成树

最小生成树 Minimum Span Tree

**V个节点 V-1条边** 说是这个图的一个生成树。生成树是包含了图中所有节点的。

最小生成树提供了一个**每个节点直接都有连通，且连通权重最小**的方案。通常是针对**带权无向图**、**连通图**。

**应用**：

电缆的布线设计

网络设计

电路设计

### 6.1 切分定理

切分定理 Cut Property

**定义**：把图中的节点分为两部分，成为一个切分（Cut）。

**横切边定义**：如果一个边的两个端点，属于切分不同的两边，那这个边称为横切边。

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\图论\切分定理.jpg" alt="切分定理" style="zoom:65%;" />

**切分定理**：给定**任意**切分，横切边中权值最小的边必然属于最小生成树。

### 6.2 Lazy Prim

涉及到的数据结构有图+最小堆。

#### 6.2.1 最小堆复现

（Java）

```java
import java.util.*;
import java.lang.*;

public class MinHeap<Item extends Comparable>{
    protected Item[] data; //堆数据
    protected int count; //堆已存数据数量
    protected int capacity; //堆容量
    
    //构建堆
    //通过一个给定数组，创建一个最小堆
    //时间复杂度为O(N)
    public MinHeap(Item[] arr){
        int n = arr.length;
        data = (Item[])new Comparable[n+1];
        capacity = n;
        count = 0;
        //转换为堆有两种方式
        //一种是遍历整个arr, 然后以添加（每次加到data尾，然后上浮）的方法一个一个的加进来 时间复杂度是O(n)
        //一种是找到最后一个非叶子节点（最后一个叶子节点的父节点），然后下沉，继续找该非叶子节点的父节点，再下沉，循环操作，直到找到根节点，执行最后一次下沉操作，时间复杂度为O(n)
        for(int i = 0; i < arr.length; i ++){
            data[i+1] = arr[i];
        }
        count = n;
        for(int i = count/2; i >= 1; i --){
            shiftDown(i);
        }
    }
    // 构造函数, 构造一个空堆, 可容纳capacity个元素
    public MinHeap(int capacity){
        data = (Item[])new Comparable[capacity+1];
        count = 0;
        this.capacity = capacity;
    }
    public int size(){
        return count;
    }
    public boolean isEmpty(){
        return count == 0;
    }
    //添加元素
    public void insert(Item item){
        assert n+1 < capacity;
        data[n+1] = item;
        count ++;
        shiftUp(count);
    }
    //移除最小元素
    public Item extractMin(){
        assert count > 0;
        Item ret = data[1];
        swap(1, count);
        count --;
        shiftDown(1);
        return ret;
    }
    //获取最小元素
    public Item getMin(){
        assert count > 0;
        return data[1];
    }
  	//上浮    
    private void shiftUp(int k){
        while( k > 1 && data[k/2].compareTo(data[k]) > 0 ){
            swap(k/2, k);
            k /= 2;
        }
    }
    //下沉
    private void shiftDown(int k){
        while(2*k <= count){
            int j = 2*k; 
            if( j+1 <= count && data[j+1].compareTo(data[j]) < 0 ){ //比较左右孩子的大小，取小的
                j ++;
            }
            if(data[k].compareTo(data[j]) < 0)
            	break;
            swap(k, j);
            k = j;
        }
        
    }
    private void swap(int i, int j){
        Item t = data[i];
        data[i] = data[j];
        data[j] = t;
    }
    
}
```

#### 6.2.2 Lazy Prim实现

（Java）

```java
import java.util.Vector;
public class LazyPrimMST<Weight extends Number && Comparable>{
    private WeightedGraph<Weight> G; //图
    private MinHeap<Edge<Weight>> pq; //最小堆
    private boolean[] marked; //标记是切分的哪一部分（就是红节点还是蓝节点）
    private Vector<Edge<Weight>> mst; //最小生成树所包含的所有边
    private Number mstWeight; //最小生成树的权值
    
    //构造函数
    public LazyPrimMST(WeightedGraph graph){
        this.G = graph;
        pq = new MinHeap<>(G.E());
        marked = new boolean[G.V()];
        for(int i = 0; i < G.V(); i ++){
            marked[i] = false;
        }
        mst.clear();
        visit(0);
        //然后从最小堆中开始取边，找点
        while( !pq.isEmpty() ){ //O(E)
            Edge<Weight> e = pq.extractMin(); //O(logE)
            //判断取出来的这个边是不是横切边（之后的步骤中，会把原来是横切边的边变为不是横切边）
            if( marked[e.v()] == marked[e.w()]){
                continue;  
            }
            //最小横切边 一定属于最小生成树 
            mst.add(e);
            //然后下一次标记的为和这个边相连的，没有被标记过的节点
            if( !marked[e.v()] ){
                visit(e.v()); 
            }else{
                visit(e.w());
            }
        }
        
        //计算最小生成树的权值
        mstWeight = mst.get(0).wt();
        for(int i = 1; i < mst.size(); i ++){
            mstWeight += mst.get(i).wt(); 
        }  
    }
    //稀疏图O(V+E) 稠密图O(V^2)
    private void visit(int v){
        assert !marked[v];
        marked[v] = true;
        //遍历节点v的临边，找到横切边，然后存进最小堆中
        for(Edge<Weight> e : G.adj(v)){
            if( !marked[e.other(v)] ){
                pq.insert(e);
            }
        }
    }
    
    //返回最小生成树的所有边
    Vector<Edge<Weight>> mstEdges(){
        return mst;
    }
    //返回最小生成树权值
    Number result(){
        return mstWeight;
    }
}
```

最终，**时间复杂度约为O(ElogE)**级别。

### 6.3 进一步优化

维护一个新的数据结构，首先可以取到最小值，其次，还可以进行更新。这就是涉及到了**索引堆**的应用。

索引堆开辟空间为V，保存的就是和这个节点相连的最短的横切边。

时间复杂度提升到了O(ElogV)

在实现过程中对于不是横切边的边会直接扔掉，不会往堆里存，所以除了对堆有所改进，遍历边的个数也更少了。

#### 6.3.1 最小索引堆复现

（Java）

```java
import java.util.*;
import java.lang.*;

//最小索引堆
public class IndexMinHeap<Item extends Comparable>{
    protected Item[] data; //数据
    protected int[] indexes; //indexes[x] = i; 表示原索引i对应的数据 在堆中位于x索引处
    protected int[] reverse; //reverse[i] = x; 表示原索引i对应的数据 在堆中位于x索引处
    //所以 reverse[indexes[x]] = x     indexes[reverse[i]] = i
    protected int count;
    protected int capacity;
    
    //构造函数 
    public IndexMinHeap(int capacity){
        this.capacity = capacity;
        data = (Item[])new Comparable[capacity+1];
        indexes = new int[capacity+1];
        reverse = new int[capacity+1];
        count = 0;
        for(int i = 0; i < reverse.length; i ++){
            reverse[i] = 0;
        }
    }
    // 返回索引堆中的元素个数
    public int size(){
        return count;
    }

    // 返回一个布尔值, 表示索引堆中是否为空
    public boolean isEmpty(){
        return count == 0;
    }
    //是否包含某元素
    public boolean contain(int i){
        assert i+1>=1 && i+1 <= count;
        return reverse[i+1] != 0;
    }
    
    //添加新元素
    public void insert(int i, Item item){
        assert count+1 <= capacity;
        assert i+1 >= 1 && i+1 <= capacity;
        //要保证指定位置是没有元素的
        if(contain(i)) return;
        data[i+1] = item; //在指定位置插入元素
        indexes[count+1] = i;
        reverse[i] = count+1;
        count ++;
        shiftUp(count);
    }
    //移除最小 返回元素值
    public Item extractMin(){
        assert count > 0;
        Item ret = data[indexes[1]];
        indexes[1] = indexes[count];
        reverse[indexes[1]] = 1;
        reverse[indexes[count]] = 0; //回到初始值
        count --;
        shiftDown(1);
        return ret;
    }
    //移除最小 返回原索引值
    public int extractMin(){
        assert count > 0;
        int ret = indexes[1]-1; //注意减1
        indexes[1] = indexes[count];
        reverse[indexes[1]] = 1;
        reverse[indexes[count]] = 0; //回到初始值
        count --;
        shiftDown(1);
        return ret;
    }
    // 获取最小索引堆中的堆顶元素
    public Item getMin(){
        assert count > 0;
        return data[indexes[1]];
    }
    // 获取最小索引堆中的堆顶元素的索引
    public int getMinIndex(){
        assert count > 0;
        return indexes[1]-1;
    }
    //改变 原索引i 的元素值
    public void change(int i, Item item){
        assert contain(i);
        i = i+1;
        data[i] = item;
        //上浮+下沉操作
        //上浮和下沉操作 操作的元素是索引数组，所以要先找到被修改元素位于堆中的位置
        int j = reverse[i];
        shiftUp(j);
        shiftDown(j);
    }
    // 获取最小索引堆中索引为i的元素
    public Item getItem( int i ){
        assert contain(i);
        return data[i+1];
    } 

    //上浮 赋值代替交换操作
    private void shiftUp(int k){
        int temp = indexes[k]; //需要进行上浮的元素
        Item tempData = data[temp];
        //k索引的indexes的父节点的索引是k/2
        //比较的是indexes[k]和indexes[k/2]所存索引的元素内容
        while( k > 1 && data[ indexes[k/2] ].compareTo( tempData ) > 0 ){
            indexes[k] = indexes[k/2];
            //注意更新reverse
            reverse[indexes[k]] = k;
            k /= 2; 
        }
        indexes[k] = temp;
        reverse[indexes[k]] = k;
    }
    //下沉 赋值代替交换操作
    private void shiftDown(int k){
        int temp = indexes[k];
        Item tempData = data[temp];
        while( k*2 <= count ){
            int j = k*2;
            if( j+1 <= count && data[indexes[j]].compareTo( data[indexes[j+1]] ) > 0 ){
                j = j+1;
            }
            if( data[j].compareTo(tempData) >= 0) break;
            indexes[k] = indexes[j];
            reverse[indexes[k]] = k;
            k = j;
        }
        indexes[k] = temp;
        reverse[indexes[k]] = k;
    }
}
```

#### 6.3.2 优化实现

（Java）

```java
import java.util.Vector;

public class PrimMST<Weight extends Number && Comparable>{
    protected WeightedGraph<Weight> G; //图
    protected IndexMinHeap<Weight> ipq; //最小索引堆 里面存的直接是最小横切边的权重值 （之前的实现存的是边）
    protected Edge<Weight>[] edgeTo; //因此还需要一个动态数组，来随时存储对应的最小横切边
    boolean[] marked; 
    protected Vector<Edge<Weight>> mst; //最小生成树的边
    protected mstWeight; //最小生成树最终权重
    
    //构造函数
    public PrimMST(WeightedGraph graph){
        G = graph;
        assert(G.E() >= 1);
        ipq = new IndexMinHeap<>(G.V()); //容量大小为节点个数
        edgeTo = new Edge[G.V()]
        marked = new boolean[G.V()]
        for(int i = 0; i < marked.length; i ++){
            marked[i] = false;
            edgeTo[i] = null;
        }
        mst = new Vector<Edge<Weight>>();
        
        //Prim
        visit(0);
        while( !ipq.isEmpty() ){
            int v = ipq.extractMinIndex();
            assert( edgeTo[v] != null );
            mst.add( edgeTo[v] ); //因为索引堆合edgeTo里面存的确定都是横切边
            visit(v); //继续这个横切边 另一个的点的临边 注意这里就是v 因为前面访问的节点是是v作为另一个点，现在是找v作为起点的另一个点，所以传v
        }
        mstWeight = mst.get(0).wt();
        for(int i = 0; i < mst.size(); i ++){
            mstWeight += mst.get(i).wt();
        }
        
    }
    private visit(int v){
        assert( !marked[v] );
        marked[v] = true;
        for(Edge<Weight> e : G.adj(v)){
            int w = e.other(v);
            if( !marked[w]){ //临边未被标记
                if(edgeTo[w] == null){
                    edgeTo[w] = e;
                    ipq.insert(w, e.wt());
                }else if(e.wt().compareTo(edgeTo[w].wt()) < 0){
                    edgeTo[w] = e;
                    ipq.change(w, e.wt());
                } 
            }
        }
    }
    //返回最小生成树的所有边
    Vector<Edge<Weight>> mstEdges(){
        return mst;
    }
    //返回最小生成树权值
    Number result(){
        return mstWeight;
    }  
}
```

通过比较，优化后的最小生成树效果更好。

### 6.4 Kruskal算法

**思想**：寻找图中最短的边，他一定属于最小生成树的边。继续寻找当前图中最短的边，如果和已定义为最小生成树的边，**不会构成环**，那么这条边也属于最小生成树的边。

为了寻找当前图最短的边，首先对所有的边进行排序 O(ElogE)

判断会不会构成环，则利用并查集的思想，比如添加两节点组成的边时，首先判断这两个节点的根节点是不是属于同一个，如果属于同一个，说明他俩本来就是连通的，如果连接上，就会形成一个环了。

#### 6.4.1 并查集 Union Find 复现

采用路径压缩的实现方式。

（Java）

```java
public class UnionFind{
    private int[] rank; //初始指向的时候用
    private int[] parent; //记录每个节点的父节点 parent[i]=x表示i的父节点为x
    private int count; //数据的个数
    
    public UnionFind(int count){
        this.count = count;
        rank = new int[count];
        parent = new int[count];
        for(int i = 0; i < count; i ++){
            rank[i] = 1;
            parent[i] = i; //初始时根节点为本身
        }
    }
    
    //查找
    public int find(int p){
        if(p < 0 || p >= count){
            throw new IllegalArgumentException("p is error");
        }
        while(p != parent[p]){ //指向本身说明是最终的根节点
            parent[p] = parent[parent[p]]; //p指向他的父节点的父节点
            p = parent[p];
        }
        return p;
    }
    /**
    //进一步路劲压缩
    public int find2(int p){
        if(p < 0 || p >= count){
            throw new IllegalArgumentException("p is error");
        }
        if( p != parent[p] ){
            parent[p] = find(parent[p]);
        }
        return parent[p]; //这样做 就一次性把当前所有子节点指向了父节点
    }
    
    public int find3(int p){
    	if(p < 0 && p >= count){
    		throw new IllegalArgumentException("p is error");
    	}
    	
    }
    private int pathCompression(int p){
    	if(parent[parent[p]] == parent[p]){
    		return parent[p]
    	}
    	parent[p] = parent[parent[p]];
    	return pathCompression(p); //每次都只调整输入p直接指向最头上的父节点
    }
    **/
    //判断是否连通
    public boolean isConnected(int p, int q){
        return find(p) == find(q);
    }
    //执行连通操作
    public void unionElements(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){
            return;
        }
        if(rank[p] > rank[q]){
            parent[qRoot] = pRoot;
        }else if(rank[p] < rank[q]){
            parent[pRoot] = qRoot;
        }else{
            parent[pRoot] = qRoot;
            rank[qRoot] += 1;
        }
    }  
}
```

#### 6.4.2 实现

（Java）

```java
import java.util.Vector;

public class KruskalMST<Weight extends Number && Comparable>{
    Vector<Edge<Weight>> mst;
    Weight mstWeight;
    
    public KruskalMST(WeightedGraph graph){
        mst = new Vector<Edge<Weight>>();
        //使用基本的堆排序
        MinHeap<Edge<Weight>> pq = new MinHeap<Edge<Weight>>(graph.E());
        for(int i = 0; i < graph.V(); i ++){
            for(Edge<Weight> e : graph.adj(i)){ //遍历当前节点的全部临边
                // 为了避免存入重复边，只存储v<w的边
                if(e.v() < e.w()){
                    pq.insert(e);
                }
            }
        }
        UnionFind uf = new UnionFind(graph.V()); //并查集用来查看已访问节点的连通情况
        while( !pq.isEmpty() && mst.size() < (graph.V()-1) ){ //mst长度为V-1
            Edge<Weight> e = pq.extractMin();
            if( uf.isConnected(e.v(), e.w()) ){
                continue;
            }
            mst.add(e);
            uf.unionElements(e.v(), e.w());
        }
        
        mstWeight = mst.get(0).wt();
        for(int i = 1; i < mst.size(); i ++){
            mstWeight += mst.get(1).wt();
        }  
    }
    
    //返回最小生成树所有边
    public Vector<Edge<Weight>> mstEdges(){
        return mst;
    }
    //返回最小生成树 权重
    public Number result(){
        return mstWeight;
    } 
}
```

### 6.5 总结

Lazy Prim	O( ElogE )                     

Prim			 O( ElogV  )                    取当前正在考虑的所有横切边中最小值边

Kruskal		O( ElogE ) 					取所有边中，没有考虑过的边的最小值边

如果横切边有相等的边，根据算法的具体实现，每次只能选择一个边。所以图此时就是存在多个最小生成树。

还有一种最小生成树的**实现思路：Vyssotsky's Algorithm**

将边逐渐（不按照特定顺序）添加到生成树中，每当产生环，就删除权重最大的那条边。最终剩下的就是最小生成树的边。（这种实现的时间复杂度高）

## 7 最短路径

前面分析的最小生成树问题，通常都是对无向带权图的操作。

本章探讨的最短路径问题，对于有向图无向图都是成立的。

4.2.1章节学习的是无权图的最短路径问题，就是通过最少的边数到达一个节点（单源最短路径问题）。本章节讨论的则均为**带权图**。

**应用**：路径规划、工作任务规划

有权图最短路径问题，可称为松弛路径问题。

### 7.1 dijkstra 单源最短路径算法

**前提：图中不能有负权边**。

时间复杂度O(ElogV )

涉及的数据结构：**索引堆**（存储和更新起点到该点的最小权值）

（Java）

```java
import java.util.Vector;
import java.util.Deque;

//Dijkstra 算法求最短路径
public class Dijstra<Weight extends Number & Comparable>{
    private WeightedGraph G; //图的引用
    private int s; //起始点
    private Number[] distTo; //distTo[i]存储从起点到i的最短路径的长度
    private boolean[] marked; //marked[i] 标记是否已找到起点到i的最短路径
    private Edge<Weight>[] from; //from[i]记录到达点i的边是哪个，可以用来重现整个最短路径。
    
    //构造函数
    public Dijstra(WeightedGraph graph, int s){
        G = graph;
        assert(s >= 0 && s < )
        this.s = s;
        distTo = new Number[G.V()];
        marked = new boolean[G.V()];
        from = new Edge<Weight>[G.V()];
        for(int i = 0; i < G.V(); i ++){
            distTo[i] = 0;
            marked[i] = false;
            from[i] = null;
        }
        //最小索引堆 记录当前找到的到达每个顶点的最短距离
        IndexMinHeap<Weight> ipq = new IndexMinHeap<>(G.V());
        
        //对起始点s进行初始化
        distTo[s] = 0;
        marked[s] = true; //这一句不加也行，因为首次访问的索引堆的最小元素 索引就是这个s
        from[s] = new Edge<Weight>(s, s, (Weight)(Number)(0.0));
        ipq.insert(s, (Weight)distTo[s]);
        while( !ipq.isEmpty() ){
            int v = ipq.extractMinIndex();
            marked[v] = true;
            //遍历v指向的所有邻边
            for(Object item : G.adj(v)){
                Edge<Weight> e = (Edge<Weight>)item;
                int w = e.other(v); //邻边的另一个点
                if(!marked[w]){ //还没找到 到w的最短路径
                    //from[w] == null 说明w还没被访问过
                    //或被访问过，但是采用松弛路径更短
                    if(from[w] == null || (distTo[v].doubleValue() + e.wt().doubleValue()) < distTo[w].doubleValue()){
                        distTo[w] = distTo[v].doubleValue() + e.wt().doubleValue();
                        from[w] = e;
                        if(ipq.contain(w)){
                            ipq.change(w, (Weight)distTo[w]);
                        }else{
                            ipq.insert(w, (Weight)distTo[w])
                        }
                    }
                }
                
            }
        }
    }
    
    //判断是否有s到w的路径
    public boolean hasPath(int w){
        assert(w >= 0 && w < G.V());
        return marked[w];
    }
    
    //返回从s到w的最短路径的长度
    public Number shortestPathTo(int w){
        assert( hasPath(w) );
        return distTo(w);
    }
    
    //寻找从s到w的最短路径，将整个路径经过的边存放在vec中
    Vector<Edge<Weight>> shortestPath(int w){
        assert( hasPath(w) );
        //通过from数组逆向查找
        Deque<Edge<Weight>> s = new ArrayDeque<>();
        Edge<Weight> e = from[w];
        while( e.v() != this.s ){
            s.push(e);
            e = from[e.v()];
        }
        s.push(e);
        //从栈中取出元素
        Vector<Edge<Weight>> res = new Vector<Edge<Weight>>();
        while( !s.isEmpty() ){
            e = s.pop();
            res.add( e );
        }
        return res;
    }
    
    //打印最短路径
    public void showPath(int w){
        assert( hasPath(w) );
        Vector<Edge<Weight>> res = shortestPah(w);
        for(int i = 0; i < res.size(); i ++){
            System.out.println(res.get(i).v() + "->"); //注意这里是v
            if( i == res.size()-1 ){
                System.out.println(res.get(i).w()); //注意这里是w
            }
        }
    }
}
```

### 7.2 有负权边问题

 **拥有负权环（环的结果和为负数）的图，没有最短路径**。因为它会在负权环中不断的绕来绕去，所以是无穷尽的。

**前提：图中能有负权边，不能有负权环**。

#### 7.2.1 Bellman-Ford 单源最短路径算法

贝尔曼-福特算法

时间复杂度O(EV)，复杂度比dijkstra高很多。

如果一个图没有负权环。从一点到另外一点的最短路径，最多经过所有的V个顶线，即V-1条边。否则，**若存在某顶点经过了两次，即存在负权环**。

参照 https://juejin.im/post/5b77fec1e51d4538cf53be68 理解。

**步骤**：

1 第一次松弛（更新）操作（初始化）

​	1.1 从原点开始，经过1条边的点的最短路径。

​	1.2 从原点开始，经过2条边的点的最短路径。

​	...

​	1.x 从原点开始，经过x条边的点的最短路径。

2 第二次松弛（更新）操作

​	2.1 从原点开始，经过1条边的点的最短路径。

​	2.2 从原点开始，经过2条边的点的最短路径。

​	...

​	2.x 从原点开始，经过x条边的点的最短路径。

... 对所有邻边点进行V-1次松弛（更新）操作，如果还可以继续松弛操作，就说明有负权环。



对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小。

如果一个图没有负权环，从一点到另外一点的最短路径，最多经过所有的V个顶线，有V-1条边。

这个算法通常针对有向图，因为如果针对无向图，点a到点b的边如果是负权边，那么点b到点a的边也是负权边，这样就相当于形成了一个负权环。

（Java）

```java
import java.util.Vector;
import java.util.Deque;

public class BellmanFord<Weight extends Number && Comparable>{
    private WeightedGraph G;
    private int s;
    private Number[] dstTo; //dstTo[i]表示到i的最短距离
    private Edge<Weight>[] from; //from[i]表示i来自的那条边
    boolean hasNegativeCycle; //标记是否有负权环
    
    //构造函数
    public BellmanFord(WeigtedGraph graph, int s){
        G = graph;
        this.s = s;
        dstTo = new Number[G.V()];
        from = new Edge<Weight>[G.V()];
        for(int i = 0; i < G.V(); i ++){
            dstTo[i] = 0;
            from[i] = null;
        }
        
        //初始化起点s
        dstTo[s] = 0;
        from[s] = new Edge<Weight>(s, s, (Weight)(Number)(0.0));
        
        //Bellman-Ford
        //进行V-1次的松弛，因为路径最长可经过V-1条边
        for(int pass = 1; pass < G.V(); pass ++){
            //遍历全部的节点，然后遍历他们的所有邻边
            for(int i = 0; i < G.V(); i ++){
                //当前遍历节点的 全部邻边
                for(Object item : G.adj(i)){
                    Edge<Weight> e = (Edge<Weight>)item;
                    //首先得保证from[e.v()]是已经可达的
                    if(from[e.v()] ！= null && ( from[e.w()] == null || (dstTo[e.w()].doubleValue() + e.wt().doubleValue()) < dstTo[e.w()].doubleValue() )){
                        dstTo[e.w()] = dstTo[e.w()].doubleValue() + e.wt().doubleValue();
                        from[e.w()] = e;
                    }
                }
            }
        }   
        hasNegativeCycle = detectNegativeCycle();
    }
    
    //判断图中是否负权环
    public boolean detectNegativeCycle(){
        //再指向V次松弛，如果可以成功执行说明有负权环，否则没有
        for(int i = 0; i < G.V(); i ++){
            for(Object item : G.adj(i)){
                Edge<Weight> e = (Edge<Weight>)item;
                if(from[e.v()] != null && (dstTo[e.w()].doubleValue() + e.wt()) < dstTo[e.w()] ){
                    return true;
                }
            }
        }
        return false;
    }
    
    // 返回图中是否有负权环
    public boolean negativeCycle(){
        return hasNegativeCycle;
    }
    
    //判断有没有s到w的路径
    public boolean hasPath(int w){
        assert(w >= 0 && w < G.V());
        return from[w] != null;
    }
    //返回从s到w最短路径
    public Number shortesPathTo(int w){
        assert( hasPath() );
        assert( !negativeCycle ); //还要保证是无负权环的！！！！！！
        return distTo[w];
    }
    
    //寻找从s到w的路径
    public Vector<Edge<Weight>> shortestPath(int w){
        assert( hasPath() );
        assert( !negativeCycle ); //还要保证是无负权环的！！！！！！
        
        Deque<Edge<Weight>> stack = new Deque<>();
        Edge<Weight> e = from[w];
        while( e.v() != s){
            stack.push(e);
            e = from[e.v()];
        }
        s.push(e);
        
        //从栈中取出，保存到Vector中
        Vector<Edge<Weight>> res = new Vector<>();
        while( !s.isEmpty() ){
            e = s.pop();
            res.add(e);
        }
        return res;
    }
    
    //打印路径信息
    public void showPath(int w){
        Vector<Edge<Weight>> path = shortestPath(w);
        for(int i = 0; i < path.size(); i ++){
            System.out.print(path.get(i).v() + "->");
            if(i == path.size()-1){
                System.out.print(path.get(i).w());
            }
        }
    }
    
    
}
```



### 7.3 其他

队列思想优化Bellman-Ford算法

有向无环图（DAG） 利用拓扑排序     时间复杂度O(V+E)



所有对最短路径算法，是回答任意两个点之间最短路径。其实运行V次的单源最短路径算法就可以得到。 Floyed算法，可以处理无负权环的图的问题，时间复杂度O(V^3)。

图中其实涉及到了动态规划的思想。

#### 7.3.1 最长路径问题

最长路径问题不能有正权环。

无权图的最长路径问题是指数级难度的

对于**有权图的最长路径问题**，不能使用Dijlstra解决，可以改Bellman-Ford解决，**实现思路**即为将所有边的权取负数，然后再寻找最短路径。这种情况下实际就是不能存在正权环（正权环取负后变为了负权环）。







有向图的环的问题

