## 1 图论基本概述

由点（节点Vertex）和边（边Edge）组成的数据结构。

交通运输、社交网络、互联网、脑区活动、程序状态执行

### 1.1 图的分类

1 图可分为无向图（Undirected Graph）和有向图（Directed Graph）。有向图就是一个节点通往另外一个节点是具有方向性的，可视化来看就是，边具有箭头属性。

无向图可以看作一种特殊的有向图。

2 无权图（Unweighted Graph）和有权图（Weighted Graph）。就是连接点和点的边有没有一个权值和他对应。比如：有权图，点表示地方，边表示两个地方的距离，边的权值就是距离值。

### 1.2 其他概念

**图的连通性**

图的节点不是全部都是连接在一起的。

**简单图**（Simple Graph）

自环边（self-loop）自己指向自己的边

平行边（parallel-edges）两个节点间有多条边连接（就像是两个地方可以有多种路径可以互通）

简单图是没有自环边和平行边的图。

## 2 图的表示

### 2.1 邻接矩阵 + 邻接表

**邻接矩阵（Adjacency Matrix）**

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\图论\二位数组-邻接矩阵.jpg" alt="二位数组-邻接矩阵" style="zoom:30%;" />

用一个**二维数组来表示一个无向图**，两个节点彼此的连接关系，0表示未连接，1表示连接。这样的一个二维数组是关于斜对角线对称的。

用二维数组也可以表示一个有向图，比如0节点指向1节点，那么arr[0] [1]为1，但是arr[1] [0]为0。

**邻接表（Adjacency Lists）**

每一行相当于一个链表：

0   1

1   0 2 3

2   1 3

3   1 2

只保存当前节点相连的节点，相较于邻接矩阵，节省了存储空间。

邻接表适合表示稀疏图（Sparse Graph），邻接矩阵适合表示稠密图（Dense Graph）

完全图 就是所有的点和所有的点都有连接。

#### 2.1.1 邻接矩阵

邻接矩阵实现稠密图

```c++
class DenseGraph{
private:
    int n, m; //n是节点个数，m是边的个数
    bool directed; //有向图无向图标志
    vector<vector<bool>> g; //邻接矩阵（二维数组）
public:
    DenseGraph(int n, bool directed){
        this->n = n;
        this->m = 0;
        this->directed = directed;
        for(int i = 0; i < n; i ++){
            g.push_back( vector<bool>(n, false) ); //每行都是n个false
        }
    }
    ~DenseGraph(){} //析构函数
    int V(){ return n; }
    int E(){ return m; }
    void addEdge(int v, int w){ //添加边 就是将两个节点进行连接操作
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        //不需要担心自环边的问题
        //为了排除平行边的问题，事先判断
        if( containEdge(v, w) ) return;
        g[v][w] = true;
        if( !directed ){ //无向图
            g[w][v] = true;
        }
        m ++;
    }
    bool containEdge(int v, int w){
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        return g[v][w];
    }
}
```

#### 2.1.2 邻接表

邻接表实现稀疏图

```c++
class SparseGraph{
private:
    int n, m;
    bool directed;
    vector<vector<int>> g; //因为一行相当于一个表，存储的是和这个节点相连的节点编号，所以此处的vector是int类型。
public:
    SparseGraph(int n, bool directed){
        this->n = n;
        this->m = 0;
        this->directed = directed;
        for(int i = 0; i < n; i ++){
            g.push_back( vector<int>() ); //默认放进来的是空的
        }
    }
    ~SparseGraph(){}
    int V(){ return n; }
    int E(){ return m; }
    void addEdge(int v, int w){
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        //若想解决平行边的问题，就需要先判断是否该边已存在，这样添加边的时间复杂度也回增加到O(n)，所以这也是邻接表可改进的点，即最后一块判断，将重复边删除。
        if(hasEdge(v, w)) return;
        g[v].push_back(w);
        //解决自环边的重复记录问题
        if( v!=w && !direxted){
            g[w].push_back(v);
        }
        m ++;
    }
    //时间复杂度大  是O(n)
    bool hasEdge(int v, int w){
        assert(v >= 0 && v < n);
        assert(w >= 0 && w < n);
        for(int i = 0; i < n; i ++){
            if(g[v][i] == w){
                return true;
            }
        }
        return false;
    }
    
}
```

**邻接表优势**：当遍历一个节点的临边时，用邻接矩阵的时间复杂度O(v)因为要遍历一整行，但是用邻接表效率就高了。

### 2.2 遍历某个节点所有的临边

#### 2.2.1 稀疏图遍历

为了使得 vector<> g 不被外部直接访问，而是作为私有属性存在，自定义一个迭代器用于外部访问。

```c++
class SparseGraph{
    ...
    class adjIterator{
    private:
        SparseGraph &G;
        int v;
        int index;
    public:
        adjIterator(SparseGraph &graph, int v):G(graph){ //继承G
            this->v = v;
            this->index = 0;
        } 
        int begin(){
            index = 0;
            if(G.g[v].size())
                return G.g[v][index];
            return -1;
        }
        int next(){
            index ++; //注意先index++
            if(index < G.g[v].size())
                return G.g[v][index];
            return -1;
        }
        bool end(){
            return index >= G.g[v].size();
        }
    }    
}


//测试
for(int v = 0; v < N; v ++){
    cout<<v<<":";
    SparseGraph::adjIterator adj(g1, v);
    for(int w = adj.begin(); !adj.end(); w = adj.next()){
        cout << w << " ";
    }
    cout << endl;
}
```

因为是可以直接获取到w值，所以遍历的时间复杂度为O(V)   V是节点个数

#### 2.2.2 稠密图遍历

也是需要自定义迭代器

它和稀疏图的不同是，这个的底层实现是邻接矩阵，所以遍历某节点所有的临边时，不能从0开始直接根据索引依次得到了，而是要寻找为true的那个位置的节点，因此，起始就是第一个为true的位置，而next就是再寻找下一个为true的位置。

```c++
class DenseGraph{
    ...
    class adjIterator{
    private:
        DenseGraph &G;
        int v;
        int index;
    public:
        adjIterator(DenseGraph &graph, int v):G(graph){
            this->v = v;
            this->index = -1; //注意这个的初始值为-1
        }
        int begin(){ //这个的begin不能从0开始了
            index = -1;
            return next(); //这里不需要判断，因为next里已经隐藏判断了
        }
        int next(){
            for(index += 1; index < G.g[v].size(); index ++){
                if(G.g[v][index])
                    return index; //注意当此时执行return index了，也就说明不会再去执行index ++了，所以下一次进来的时候的index还是此时的index，所以依旧需要先index+=1。
            }
            return -1;
        }
        bool end(){
            return index >= G.g[v].size();
        }
    }
}

//测试
for(int v = 0; v < N; v ++){
    cout << v << ": ";
    DenseGraph::adjIterator adj2(g2, v);
    for(int w = adj2.begin(); !adj2.end(); w = adj2.next()){
        cout << w << " ";
    }
    cout << endl;
}
```

因为邻接矩阵的实现特点，当找next的时候需要遍历行，因为时间复杂度为O(V^2)。

由此可以看出，邻接表实现的稀疏图在遍历某节点的所有相邻边问题上更有优势。

## 3 图的进一步实现

### 3.1 从文件读取图的实现

文件首行存储图的节点数和图的边数，下面的行存储图相连接的节点。通过读取文件内容，生成一个图，将其封装为一个方法类。

因为封装成了一个模板类，所以稀疏图和稠密图的类都需要继承Graph的接口。

```c++
template <typename Graph>
class ReadGraph{
public:
    ReadGraph(Graph &graph, const string &filename){
        ifstream file(filename);
        string line;
        int V, E;
        assert( file.is_open() );
        assert( getline(file, line) );
        stringstream ss(line);
        ss>>V>>E;
        assert( V == graph.V() );
        for(int i = 0; i < E; i ++){
            assert( getline(file, line) );
            stringstream ss(line);
            int a,b;
            ss>>a>>b;
            graph.addEdge(a, b);
        }
    }
}
```

## 4 图的遍历

### 4.1 深度优先遍历 dfs

以求连通分量为例，实现深度优先遍历，这个深度优先遍历也涉及到了一个思想，即**回溯思想**。

使用并查集只能来判断两个节点是否相连，但是使用图论就可以看到两个相连节点的路径是怎么样的。

稀疏图的时间复杂度 O(V+E)   稠密图的时间复杂度 O(V^2)

深度优先遍历算法对有向图依然有效。

```c++
#inndef GRAPH_COMPONENT_H
#define GRAPH_COMPONENT_H

#include <iostream>
#include <cassert>
using namespace std;

template <typename Graph>
class Component{
private:
    Graph &G;
    bool *visited; //记录当前节点被访问的状态
    int ccount; //记录包含几个连通图
    int *ids; //记录是否在一个连通图内
    //深度优先遍历
    void dfs(int v){
        //首先将当前遍历的这个节点的访问状态定为true
        visited[v] = true;
        //然后深度遍历该节点的相邻边
        typename Graph::adjIterator adj(G, v);
        for(int i = adj.begin(); !adj.end(); i = adj.next()){
            if( !visited[i] )
                dfs[i];
        }
    }
public:
    Component(Graph &graph):G(graph){
        visited = new bool[G.V()];
        ids = new int[G.V()];
        ccount = 0;
        for(int i = 0; i < G.V(); i ++){
            visited[i] = false;
            ids[i] = -1; //初始为-1  哪个也不属于
        }
        for(int i = 0; i < G.V(); i ++){
            if( !visited[i] ){
                dfs(i); //深度遍历该节点
                ccount ++; //该节点回溯回来说明此时形成了一个连通图了
            }
        }
    }
    ~Component(){
        delete[] visited;
        delete[] ids;
    }
    int count(){
        return ccount;
    }
    bool isConnected(int v, int w){
        //判断v, w合不合理
        assert( v >= 0 && v < G.V() );
        assert( w >= 0 && w < G.V() );
        return ids[v] == ids[w];
    }
}
```

#### 4.1.1 寻路

此处只是为了获取路径，而不是要求最短路径。

寻路也是通过深度优先遍历实现的。深度优先遍历通过递归实现，打印路径助栈实现。

```c++
class Path{
private:
    Graph &G;
    int s;
    bool *visited;
    int *from; //存放到到达前节点的前一个节点
    
    dfs(int s){
        visited[s] = true;
        typename Graph::adjIterator adj(G, v);
        for(int i = adj.begin(); !adj.end(); i = adj.next()){
            if( !visited[i] ){
                from[i] = v;
                dfs(i);
            }
        }
        
    }
public:
    Path(Graph &graph, int s):G(graph){ //:G(graph)是初始化列表  //s是输入起点
        assert( s >= 0 && s < G.V() );
        
        visited = new bool[G.V()];
        from = new int[G.V()];
        for(int i = 0; i < G.V(); i ++){
            visited[i] = false;
            from[i] = -1; //起点位置会一直定义为-1的
        }
        this->s = s;
        
        //寻路算法
        dfs(s);//输入起点
    }
    ~Path(){
        delete[] visited;
        delete[] from;
    }
    bool hasPath(int w){ //w是指的路径的终点，判断有没有这个路径
        //如果w这个节点被访问过，也就是到达过这个w
        return visited[w];
    }
    
    void path(int w, vector<int> &vec){
        stack<int> s;
        int p = w;
        while( p != -1 ){
            s.push(p);
            p = from[p]; //找到当前p的来自的节点，继续找，直到找到起点
        }
        vec.clear();
        while( !s.empty() ){
            vec.push_back( s.top() );
            s.pop();
        }
    }
    
    void showPath(int w){ //打印找到的路径
        vector<int> vec;
        path(w, vec);
        for(int i = 0; i < vec.size(); i ++){
            cout << vec[i];
            if(i == vec.size()-1){
                cout << endl;
            }else{
                cout << "->";
            }
        }
    }
    
}
```

### 4.2 广度优先遍历

广度优先遍历，又称层数优先遍历，就是距离起始点的层数的先后。

根据这种特性，寻找的路径就是最短路径

**应用：求出无权图的最短路径**，广度优先遍历借助队列实现。

稀疏图的时间复杂度 O(V+E)   稠密图的时间复杂度 O(V^2)

#### 4.2.1 无权图的最短路径

```c++
template <typename Graph>
class ShortestPath{
private:
    Graph &G;
    int s;
    bool *visited;
    int *from;
    int *ord;
public:
    ShortestPath(Graph &graph, int s):G(graph){
        assert( s >= 0 && s < graph.V() );
        visited = new bool[G.V()];
        from = new int[G.V()];
        ord = new int[G.V()];
        for(int i = 0; i < G.V(); i ++){
            visited[i] = false;
            from[i] = -1;
            ord[i] = -1;
        }
        this->s = s;
        
        //队列实现
        queue<int> q;
        q.push( s );
        visited[s] = true;
        ord[s] = 0; //起点距离起点为0
        
        while( !q.empty() ){
            int v = q.front();
            q.pop();
            typename Graph::adjIterator adj(G, v);
            for(int i = adj.begin(); !adj.end(); i = adj.next()){
                if(!visited[i]){
                    visited[i] = true;
                    q.push(i);
                    from[i] = v;
                    ord[i] = ord[v]+1;
                }
            }
        }

    }
    ~ShortedPath(){
        delete[] visited;
        delete[] from;
        delete[] ord;
    }
    bool hasPath(int w){
        assert( w >= 0 && w < G.V() );
        return visited[w];
    }
    void path(int w, vector<int> &vec){
        assert( w >= 0 && w < G.V() )
        stack<int> ss;
        int p = w;
        while( p != -1 ){
            ss.push(p);
            p = from[p];
        }
        vec.clear();
        while( !ss.empty() ){
            vec.push_back(ss.top());
            ss.pop();
        }
        
    }
    void showPath(int w){
        vector<int> vec;
        path(w, vec);
        for(int i = 0; i < vec.size(); i ++){
            cout << vec[i];
            if( i == vec.size() - 1 ){
                cout << endl;
            }else{
                cout << "->";
            }
        }
    }
    
    int length(int w){
        assert( w >= 0 && w < G.V() );
        return ord[w];
    }
}
```















有向图的环的问题

