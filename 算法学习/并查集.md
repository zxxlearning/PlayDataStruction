**并查集**主要用于**解决连接问题**，连没连一起，属不属于一个集合这一类的。

## 1 连接问题

Connectivity Problem

还可以解决数学的集合问题。

连接问题比路径问题，所回答的东西要少。因为连接问题，只需要回答是不是连接，而不需要回答出具体的路径。

<u>实现一个算法问题时，可以考虑一下是不是额外的回答了一些别的问题，其实少回答一些问题就是一种优化</u>。

### 1.1 并查集实现

```c++
#include <iostream>
#include <cassert>

using namespace std;

class UnionFind(){
private:
    int* id; //存放集合标志id, 初始化自己的就是自己的初始id
    int count;

public:
    UnionFind( int n ){
        count = n;
        id = new int[n];
        for(int i = 0; i < n; i ++){
            id[i] = i;
        }
    }
    
    ~UnionFind(){
        delete[] id;
    }
    
}
```

#### 1.1.1 快速查找 Quick Find

查找某个元素属于哪个集合。

根据id找到 查看 元素对应的 id[] 这个数组的对应位置的id号就是这个元素对应的集合编号。

（C++）

```c++
//时间复杂度O(1)
public:
    //快速查找法
    int find( int p ){
        assert( p >= 0 && p < count );
        return id[p];
    }
```

（Java）

```java
private int[] id;
public UnionFind(int count){
    id = new int[count];
    for(int i = 0; i < count; i++){
        id[i] = i;
    }
}
public int find(int p){
    if(p<0 || p>=id.length){
        throw new IllegalArgumentException("Illegal Index !");
    }
    return id[p];
}
```

#### 1.1.2 连接 isConnected

（C++）

```java
//时间复杂度O(1)
public:
	bool isConnected( int p, int q ){
        return find(p) == find(q);
    }
```

（Java）

```java
public bool isConnection(int p, int q){
    return find(p) == find(q);
}
```

#### 1.1.3 合并 unionElements

union在C++中是关键字，不能用它做方法名，所以方法名命为unionElements。为了合并两个元素，需要遍历数组全部元素找到要合并的元素。时间复杂度是O(N)。

（C++）

```c++
public:
	void unionElements(int p, int q){
        int pId = find(p);
        int qId = find(q);
        if(pId == qId){
            return;
        }
        for(int i = 0; i < count; i ++){
            if(id[i] == pId){
                id[i] = qId;
                return;
            }
        }
    }
```

（Java）

```java
public void unionElements(int p, int q){
    int pId = find(p);
    int qId = find(q);
    if(pId == qId){
        return;
    }
    //有这个循环是因为，所有属于pId的元素都要变成属于qId
    for(int i = 0; i < id.length; i++){
        if(id[i] == pId){
            id[i] = qId;
            return;
        }
    }
}
```

### 1.2 优化实现

之间合并的时间复杂度是O(N)。为了优化，想一下树的类似结构。将每个元素看作一个节点，但是这个节点和之前学习的树的节点不一样，他更像是一种森林结构。每个节点指定自己的父亲节点，指向相同祖先节点的节点们是相连接的。**查询和合并都是树的深度的时间复杂度**。

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\并查集优化实现1.png" alt="并查集优化实现1" style="zoom:50%;" />

#### 1.2.1 快速合并 Quick Union

底层实现依旧可以采用数组实现。具有相同祖先节点表示连接在一起，但是数组中存的是父节点。

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\优化并查集的底层实现.png" alt="优化并查集的底层实现" style="zoom:40%;" />

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\优化并查集的底层实现2.png" alt="优化并查集的底层实现2" style="zoom:70%;" />

查询的时间复杂度 从O(1)变成了树的深度的时间复杂度。

(C++)

```java
public:
	UnionFind(int count){
        parent = new int[count];
        this->count = count;
        for(int i = 0; i < count; i ++){
            parent[i] = i; //最初每个人的父节点都是本身
        }
    }
	~UnionFind(int count){
        delete[] parent;
    }
	//查询操作
	int find(int p){
        assert(p < 0 || p >= count);
        while( p != parent[p]){
            p = parent[p];
        }
        return p;
    }
	//判断是否连接
	boolean isConnected(int p, int q){
        return find(p) == find(q);
    }
	//合并两个元素
	void unionElements(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){
            return;
        }
        //他们必须具有相同的祖先节点
        parent[pRoot] = parent[qRoot];
    }
```

(Java)

```java
//查询操作
public int find(int p){
    if(p < 0 || p >= parent.length)
        throw new IllegalArgumentException("illegal");
    while(p != parent[p]){
        p = parent[p];
    }
    return p;
}
//合并操作
public void unionElements(int p, int q){
    int pRoot = find(p);
    int qRoot = find(q);
    if(pRoot == qRoot){
        return;
    }
    parent[pRoot] = qRoot;
}
```

经过测试，这种并查集 效率高一点点。

#### 1.2.2 根据size进行优化

上面那种优化还存在一个问题，就是合并两个元素时，是直接将一个的祖先节点指向了另一个人的祖先节点。所以很容易出现，长的指向短的，导致树的深度增加，查询和合并的时间复杂度也跟着增加。

为了解决这个问题，在进行祖先节点的指向前，先判断那段长，然后**用短的指向长的**。

（C++）

```c++
private:
	int* parent;
	int count;
	int* sz; //表示以i为根的集合种有几个元素
public:
	UnionFind(int count){
        parent = new Parent[count];
        this->count = count;
        for(int i = 0; i < count; i ++){
            parent[i] = i;
            sz[i] = 1;
        }
    }
	~UnionFind(){
        delete[] parent;
        delete[] sz;
    }
	//合并
	void unionElements(int p, int q){
        pRoot = parent[p];
        qRoot = parent[q];
        if(qRoot == qRoot){
            return;
        }
        if(sz[pRoot] > sz[qRoot]){
            parent[qRoot] = pRoot; //短的指向长的
            sz[pRoot] += sz[qRoot];
        }else{
            parent[pRoot] = qRoot;
            sz[qRoot] += sz[pRoot];
        }
    }
```

（Java）

```java
public void unionElements( int p, int q ){
    int pRoot = parent[p];
    int qRoot = parent[q];
    if(pRoot == qRoot){
        return;
    }
    if(sz[pRoot] > sz[qRoot]){
        parent[qRoot] = pRoot;
        sz[pRoot] += sz[qRoot];
    }else{
        parent[pRoot] = qRoot;
        sz[qRoot] += sz[pRoot];        
    }
}
```

性能效率优化了很多很多。

#### 1.2.3 根据rank进行优化

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\选择用rank优化的原因.png" alt="选择用rank优化的原因" style="zoom:50%;" />

上面根据集合的size进行的优化，其实还是不够好，因为时间复杂度和树的深度有关，所以更好的选择是根据树的深度，即层数进行优化。

rank[i]表示根节点

（C++）

```c++
int* rank; //初始都是1，表示只有自己本身
public:
	void unionElements( int p, int q ){
        int pRoot = parent[p];
        int qRoot = parent[q];
        if(pRoot == qRoot){
            return;
        }
        if(rank[pRoot] > rank[qRoot]){ //短的指向长的，那么长的rank还是不变的，因为短的加进来，不会增长
            parent[qRoot] = pRoot;
        }else if(rank[pRoot] < rank[qRoot]){
            parent[pRoot] = qRoot;
        }else{ //此时谁指向谁都可以
            parent[pRoot] = qRoot;
            rank[qRoot] += 1;
        }  
    }

```