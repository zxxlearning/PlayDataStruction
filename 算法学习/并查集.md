**并查集**主要用于**解决连接问题**，连没连一起，属不属于一个集合这一类的。

## 1 连接问题

Connectivity Problem

还可以解决数学的集合问题。

连接问题比路径问题，所回答的东西要少。因为连接问题，只需要回答是不是连接，而不需要回答出具体的路径。

<u>实现一个算法问题时，可以考虑一下是不是额外的回答了一些别的问题，其实少回答一些问题就是一种优化</u>。

### 1.1 并查集实现

```c++
#include <iostream>
#include <cassert>

using namespace std;

class UnionFind(){
private:
    int* id; //存放集合标志id, 初始化自己的就是自己的初始id
    int count;

public:
    UnionFind( int n ){
        count = n;
        id = new int[n];
        for(int i = 0; i < n; i ++){
            id[i] = i;
        }
    }
    
    ~UnionFind(){
        delete[] id;
    }
    
}
```

#### 1.1.1 快速查找 Quick Find

查找某个元素属于哪个集合。

根据id找到 查看 元素对应的 id[] 这个数组的对应位置的id号就是这个元素对应的集合编号。

（C++）

```c++
//时间复杂度O(1)
public:
    //快速查找法
    int find( int p ){
        assert( p >= 0 && p < count );
        return id[p];
    }
```

（Java）

```java
private int[] id;
public UnionFind(int count){
    id = new int[count];
    for(int i = 0; i < count; i++){
        id[i] = i;
    }
}
public int find(int p){
    if(p<0 || p>=id.length){
        throw new IllegalArgumentException("Illegal Index !");
    }
    return id[p];
}
```

#### 1.1.2 连接 isConnected

（C++）

```java
//时间复杂度O(1)
public:
	bool isConnected( int p, int q ){
        return find(p) == find(q);
    }
```

（Java）

```java
public bool isConnection(int p, int q){
    return find(p) == find(q);
}
```

#### 1.1.3 合并 unionElements

union在C++中是关键字，不能用它做方法名，所以方法名命为unionElements。为了合并两个元素，需要遍历数组全部元素找到要合并的元素。时间复杂度是O(N)。

（C++）

```c++
public:
	void unionElements(int p, int q){
        int pId = find(p);
        int qId = find(q);
        if(pId == qId){
            return;
        }
        for(int i = 0; i < count; i ++){
            if(id[i] == pId){
                id[i] = qId;
                return;
            }
        }
    }
```

（Java）

```java
public void unionElements(int p, int q){
    int pId = find(p);
    int qId = find(q);
    if(pId == qId){
        return;
    }
    for(int i = 0; i < id.length; i++){
        if(id[i] == pId){
            id[i] = qId;
            return;
        }
    }
}
```

### 1.2 优化实现

之间合并的时间复杂度是O(N)。为了优化，想一下树的类似结构。将每个元素看作一个节点，但是这个节点和之前学习的树的节点不一样，他更像是一种森林结构。每个节点指定自己的父亲节点，指向相同祖先节点的节点们是相连接的。查询和合并都是树的深度的时间复杂度。

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\并查集优化实现1.png" alt="并查集优化实现1" style="zoom:50%;" />

#### 1.2.1 快速合并 Quick Union

底层实现依旧可以采用数组实现。具有相同祖先节点表示连接在一起，但是数组中存的是父节点。

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\优化并查集的底层实现.png" alt="优化并查集的底层实现" style="zoom:40%;" />

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\并查集\优化并查集的底层实现2.png" alt="优化并查集的底层实现2" style="zoom:70%;" />

