# 动态规划

一般是求解最值问题。

三要素：重叠子问题、最优子结构，状态转移方程。

最优子结构问题：可以从子问题的最优结果推出更大规模问题的最优结果。想满足最优子结构，子问题之间必须互相独立。

最优子结构，不是动态规划问题特有的性质。而是其他最值也共有的特性。

**如何列出状态转移方程？**

先确定状态（原问题和子问题中变化的变量）

再确定dp函数的定义

确定“选择”，并择优

结束情况（base case）

**dp数组的遍历状态的选择？**

1 遍历的过程，所需的状态必须是base case或已经计算出来的。

2 遍历的终点必须是存储结果的那个位置。

# 动态规划应用

## 最值问题

#### [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```JAVA
class Solution {
    public int coinChange(int[] coins, int amount) {
        //动态规划求解最值问题 dp[n]
        //首先确定状态 就是原问题和子问题中变化的量 此处就是将 n 定义为总金额数
        //然后确定dp函数的含义，此处dp[n]就是n的总金额数所需要的最少硬币个数
        //确定“选择” 就是总金额为n的全部选择，然后再择优，择优结果即dp[n]
        //确定base case: n=0 dp[n]=0, n<0, dp[n]=-1
        int[] dp = new int[amount+1];
        dp[0] = 0;
        for(int i = 1; i <= amount; i ++){
            int res = Integer.MAX_VALUE;
            for(int coin : coins){
                if( (i-coin) < 0 || dp[i-coin] == Integer.MAX_VALUE) continue;
                res = Math.min(res, 1 + dp[i-coin]);
            }
            dp[i] = res;
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```

> 执行用时 :14 ms, 在所有 Java 提交中击败了85.82%的用户
>
> 内存消耗 :39.6 MB, 在所有 Java 提交中击败了5.77%的用户

#### [零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

```java
class Solution {
    int res = 0;
    public int change(int amount, int[] coins) {
        //动态规划
        //dp[n] n是金额，dp[n]是n金额的所有组合数
        //base case dp[0]=1
        int[] dp = new int[amount+1];
        dp[0] = 1;
        for(int coin : coins){
            for(int i = coin; i <= amount; i ++){
                dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }
}
```

> 执行用时 :2 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗 :37.1 MB, 在所有 Java 提交中击败了8.33%的用户

## 子序列问题

#### [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int[][] dp = new int[n][n]; //默认初始化值为0
        //i < j
        for(int i = n-1; i >=  0; i --){
            dp[i][i] = 1;
            for(int j = i+1; j < n; j ++){
                if(c[i] == c[j]){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = Math.max( dp[i][j-1], dp[i+1][j] );
                }
            }
        }
        return dp[0][n-1];
    }
}
```

> 执行用时 :19 ms, 在所有 Java 提交中击败了97.85%的用户
>
> 内存消耗 :49.8 MB, 在所有 Java 提交中击败了6.90%的用户

## 贪心系列

贪心算法 可看作动态规划问题的一个特例。效率也比动态规划高。

**贪心算法性质**（特殊性质、并非所有贪心系列的题都满足）：

每一步做出一个局部最优的选择，最终的结果就是全局最优。

#### [最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

主要是用到了回文串的特性。

```java
class Solution {
    public int longestPalindrome(String s) {
        //该题就统计 出现奇数次的字符，因为回文串中最多只能出现1个出现奇数次的字符
        //试验证明  用数组比 hashmap快
        int[] cnt = new int[58];
        for (char c : s.toCharArray()) {
            cnt[c-'A'] += 1;
        }
        int count = 0; //统计奇数字符的个数
        for(int x : cnt){
            count += (x & 1);
        }
        return (count == 0) ? s.length() : (s.length() - count + 1);
    }
}
```

> 执行用时 :1 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗 :37.7 MB, 在所有 Java 提交中击败了5.00%的用户

### 区间调度类型

