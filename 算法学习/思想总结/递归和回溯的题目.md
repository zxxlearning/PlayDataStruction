### [1. 全排列（无重复）](https://leetcode-cn.com/problems/permutations/)

套用回溯算法的模板

**res.add(new ArrayList<>(board))**; //注意这里不能直接加board 因为board是引用类型，它变化，这个也会变化。

该模板方法中，list.contains()方法耗时O(n)，为了进一步优化这个问题，多开辟一个boolean类型数组，来代替选择列表涉及的判断实现。见法2。

#### 法1 回溯模板

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> board = new ArrayList<>();
        backtract(board, nums);
        return res;
    }
    //回溯实现，传入路径和选择
    private void backtract(List<Integer> board, int[] nums){
        //终结条件
        if(board.size() == nums.length){
            // System.out.println(board);
            res.add(new ArrayList<>(board)); //注意这里不能直接加board  因为board是引用类型，它变化，这个也会变化。
            return;
        }
        //回溯内部递归的实现
        for(int i = 0; i < nums.length; i ++){
            if(board.contains(nums[i])){
                continue;
            }
            board.add(nums[i]); //做出选择
            backtract(board, nums);
            board.remove(board.size()-1);
        }
    }
}
```

> 执行用时 :3 ms, 在所有 Java 提交中击败了45.11%的用户
>
> 内存消耗 :39.9 MB, 在所有 Java 提交中击败了7.32%的用户

#### 法2 回溯模板--小优化

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> board = new ArrayList<>();
        boolean[] flag = new boolean[nums.length];
        backtract(board, nums, flag);
        return res;
    }
    //回溯实现，传入路径和选择
    private void backtract(List<Integer> board, int[] nums, boolean[] flag){
        //终结条件
        if(board.size() == nums.length){
            // System.out.println(board);
            res.add(new ArrayList<>(board)); //注意这里不能直接加board  因为board是引用类型，它变化，这个也会变化。
            return;
        }
        //回溯内部递归的实现
        for(int i = 0; i < nums.length; i ++){
            if(flag[i]){
                continue;
            }
            board.add(nums[i]); //做出选择
            flag[i] = true;
            backtract(board, nums, flag);
            board.remove(board.size()-1);
            flag[i] = false;
        }
    }
}
```

> 执行用时 :2 ms, 在所有 Java 提交中击败了82.31%的用户
>
> 内存消耗 :40.3 MB, 在所有 Java 提交中击败了7.32%的用户

### [2. 全排列 II（有重复）](https://leetcode-cn.com/problems/permutations-ii/)

#### 法 回溯模板为基础

（想到了思路，但是没实现出来...）

该题和上一题的区别是有重复元素，因此，要重新设计路径的选择操作。

首先执行数组的排序，这样通过比较当前元素和前一个元素，就能判断当前元素是否是重复元素，而重复元素直接掠过，不参与路径选择。根据这个思想，进行路径选择的剪枝。

**剪枝实现的关键代码**

```java
//表示前面那个选项刚刚被撤销，也就是此时他们是同一行的
if(i > 0 && nums[i] == nums[i-1] && !flag[i-1]){ 
    continue;
}
```

注意这个回溯是从上到下，再从下到上，再从上到下的一个递归循环....

**!flag[i-1]** 就保证了当前的nums[i]和nums[i-1]是位于决策树同一行的。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        //先排序(从小到大，重复的在一起)
        Arrays.sort(nums);
        Deque<Integer> board = new ArrayDeque<>();
        boolean[] flag = new boolean[nums.length];
        backtract(board, nums, flag, 0);
        return res;
    }
    // 路径 选择 标记 长度标记
    private void backtract(Deque<Integer> board, int[] nums, boolean[] flag, int index){
        if(index == nums.length){
            res.add(new ArrayList<>(board));
            return;
        }
        //回溯内部循环
        for(int i = 0, j = 0; i < nums.length; i ++){
            if(flag[i]){
                continue;
            }
            if(i > 0 && nums[i] == nums[i-1] && !flag[i-1]){ //表示前面那个选项刚刚被撤销，也就是此时他们是同一行的
                continue;
            }
            board.push(nums[i]);
            flag[i] = true;
            backtract(board, nums, flag, index+1);
            board.pop();
            flag[i] = false;
        }
    }
}
```

> 执行用时 :2 ms, 在所有 Java 提交中击败了79.14%的用户
>
> 内存消耗 :40.6 MB, 在所有 Java 提交中击败了12.50%的用户

