## 1 1~n整数中出现某个数字的次数

以出现1的次数为例。时间复杂度定义在和数字n的位数有关上，即时间复杂度为O(logn)。

#### 解题思路

判断1~n整数中，每个 位数（个、十、百...）上的出现1的次数相加，就是最终出现1的次数。

将整数n分为高 + 当前 + 低 三段。

初始化时 当前为个位，高为除个位之外的位数。

当前位（个位==d=1, 十位==d=10, 百位==d=100 ....）

1 当当前的位数 值 = 0时，    结论：出现1的次数为 **高*d**

2 当当前的位数 值 = 1时，    结论：出现1的次数为 **高*d + 低+1**

3 当当前的位数 值 = 2~9时，结论：出现1的次数为 **（高+1）*d**

## 2 数字序列中某一位的数字

数字以**0123456789101112131415…**的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

#### 解题思路

<img src="D:\DataFiles\Learn\Github\PlayDataStruction\算法学习\pics\涉及数字位数问题\数字序列指定位数.png" alt="数字序列指定位数" style="zoom:65%;" />

步骤：

1 首先判断位数n属于哪个数字范围内

​		n-=当前的count 直到n < 当前的count，说明找到了所属范围。

2 然后判断在这个范围内，指向了哪个数字

​		此时的n就是所在数字范围从头开始数的位数（注意是从1开始的）。即比如：

​	 	     1 0  1 1  1 2  1 3...              **d=2**

​	n	    1 2  3 4  5 6  7 8...

  n-1       0 1  2 3  4 5  6 7...

(n-1)/d   0 0  1 1  2 2  3 3...

​		**num = (n-1)%d + start**

3 最后判断指向了这个数字的哪一位

​	 	     1 0  1 1  1 2  1 3...            **d=2**

​	n	    1 2  3 4  5 6  7 8...

  n-1       0 1  2 3  4 5  6 7...

(n-1)%d 0 1  0 1  0 1  0 1...

根据位置找具体值，数值不好处理，所以此处先转为string，然后取charAt(p)。

Long.toString(num).charAt(p) - '0'; **//注意转成int 不能直接字符转，得-'0'**