## 2.1 不要小瞧数组

​	声明数组时的注意事项：

> 1. 声明一个数组时就要声明这个数组的长度。例如：int[] arr = new int[10];
>
> 2. 若没有声明数组长度，就必须声明数组内容。例如：int[] arr = new int[]{1,2,3,4}; 或 int[] arr = {1,2,3,4}
>
> 3. 遍历数组的时候，除了用一般的for循环还可以用for each结构。例如：for(int num: arr){}

​	数组最大的优点是：快速查询。

​	数组最好是用在索引有语义的情况下。比如说：score[2]，表示学号为2的同学的成绩。

## 2.2 二次封装属于我们自己的数组

​	Java本身给我们提供的数组，在刚开始定义的时候就要完成数组长度的设置了。

```java
int[] score = new int[10];
score[0] = 100;
score[1] = 98;
score[2] = 66;
```

​	对于上面定义的score数组，只给数组前三个位置上赋值了。如何表示没有赋值的数组元素呢？如何十个值都插满了，数组本身长度又是固定住的，如何新插入元素或者删除元素呢？这对于Java自身提供的数组来说，是个问题，这就需要我们基于Java数组，二次封装动态数组。

## 2.3 封装 int 类型的数组

## 2.4 使用泛型

​	在Java中，定义泛型容器时，泛型不能包括基本数据类型，即boolean、byte、char、short、int、long、float、double；而必须是类对象，即Integer、Double这种才可以。基本类型和包装类在需要的时候可以自动进行相互转换。Object类是任意类的父类。

​	**equals比较和==比较，前者是值比较，后者是引用指向的比较**。

## 2.5 动态数组

​	当一个数组已经满了，但是还想往里面加元素的时候。新new一个容量更大的数组（建议定义为原数组的倍数，而不是加一个常数值），然后把原数组里的元素都复制到新数组中，把原数组指向新数组。

​	由于原数组data是封装的数组类中的自己的变量元素，而新数组是在一个扩容方法中的临时数组，所以当这个方法结束后，Java垃圾回收机制就会把新数组回收掉（回收的是栈内原指向新数组的变量），而原data也已改变了指向，指向了新数组（堆内存中的新数组内容）。

## 2.6 简单的时间复杂度分析

​	O（）是渐进时间复杂度，描述的是 n 趋于无穷的情况。**所以当n较小时，还要考虑常数**，O（n）不一定比O（n2）快呀。比如：T = 2000×n + 10000 O（n）和 T = 1×n×n+1 O（n2）。当n取5时，O（n）对应的时间更久呀！所以**对于比较小的数据量，阶高的复杂度对应的常数小时，可以选择阶高的复杂度对应的算法用**。（比如小数据量的排序算法，直接插入排序就效率很好）

​	有时候，算法复杂度是浮动的，根据参数不同，复杂度也不同。此时就考虑用每个参数的概率，然后算这些参数的期望值作为复杂度。比如前面封装数组类中的定义的添加方法，添加的位置index是不确定的，对应的算法复杂度也是不同的。也叫 “均摊复杂度” 。

​	考虑时间复杂度通常考虑最坏情况。

## 2.7 震荡时间复杂度

​	当数组元素满了，进行一次添加操作，会触及resize方法，时间复杂度为O（n）；按均摊复杂度来说是O（1），接着进行一次删除操作，也会触及resize方法，时间复杂度为O（n）；再进行一次添加操作，会触及resize方法，时间复杂度为O（n）；也就是从O（1）突然蹦到O（n），循环震荡的时间复杂度。

​	是因为在删除操作中，当size等于容量一半时就进行resize是一种激进（Eager）做法。可以选择一种Lazy做法。就是当size等于容量的四分之一时，再去触及resize方法。

