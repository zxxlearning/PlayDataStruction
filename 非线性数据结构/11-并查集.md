## 11.1 并查集

​		并查集常会被用来解决**连接问题**。

​		定义并查集接口

```java
public interface UF {
    boolean isConnected(int p, int q);
    void unionElements(int p, int q);
}
```

#### 11.1.1 Quick Find

​	isConnected的时间复杂度是O（1），unionElements（就是进行合并的方法）的时间复杂度是O（n）,要遍历整个数组。如果一个算法的时间复杂度是O（n），就是说明这个算法是比较差的，是需要进行改进的。

```java
public class UnionFind1 implements UF{

    private int[] id;

    public UnionFind1(int size){
        id = new int[size];
        for(int i = 0; i < id.length; i ++){
            id[i] = i;
        }
    }

    @Override
    public int getSize() {
        return id.length;
    }

    private int find(int p){
        if(p < 0 || p > id.length){
            throw new IllegalArgumentException("Illegal index !");
        }
        return id[p];
    }

    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    @Override
    public void unionElements(int p, int q) {
        int idP = find(p);
        int idQ = find(q);
        if(idP == idQ){
            return;
        }
        for(int i = 0; i < id.length; i ++){
            if(id[i] == idP){
                id[i] = idQ;
            }
        }
    }
}
```

#### 11.1.2 Quick Union

​	相当于一个森林结构。底层结构用数组实现。查询和合并都是树的深度的时间复杂度。

```java
public class UnionFind2 implements UF {

    private int[] parent;

    public UnionFind2(int size){
        parent = new int[size];
        for(int i = 0; i < parent.length; i ++){
            parent[i] = i;
        }
    }

    @Override
    public int getSize() {
        return parent.length;
    }

    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        //指向本身说明是根节点
        while(parent[p] != p){
            p = parent[p]; //如果不指向本身，就再去找父亲节点的父亲节点。
        }
        return p;
    }
    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
    @Override
    public void unionElements(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){ //如果最头头的父节点一样说明在一个集合了
            return;
        }
        parent[pRoot] = qRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
    }
}
```

#### 11.1.3 根据size进行优化

合并的时候有一步是一个指向另一个的操作，如果随便指，长的指向短的时候，深度就会越来越深，时间复杂度就加大了，所以，在合并前判断一下，叫短的指向长的，这样就优化了树的深度。

```java
public class UnoinFind3 implements UF {

    private int[] parent;
    private int[] sz; // 表示以i为根的集合中元素的个数

    public UnoinFind3(int size){
        parent = new int[size];
        sz = new int[size];
        for(int i = 0; i < parent.length; i ++){
            parent[i] = i;
            sz[i] = 1;
        }
    }

    @Override
    public int getSize() {
        return parent.length;
    }

    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        //指向本身说明是根节点
        while(parent[p] != p){
            p = parent[p]; //如果不指向本身，就再去找父亲节点的父亲节点。
        }
        return p;
    }
    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
    @Override
    public void unionElements(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){ //如果最头头的父节点一样说明在一个集合了
            return;
        }
        if(sz[pRoot] < sz[qRoot]){
            parent[pRoot] = qRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
            sz[qRoot] += sz[pRoot];
        }else{
            parent[qRoot] = pRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
            sz[pRoot] += sz[qRoot];
        }

    }
}
```

#### 11.1.4 基于rank的优化

```java
public class UnionFind4 implements UF{

    private int[] parent;
    private int[] rank; // 表示以i为根的集合的深度

    public UnionFind4(int size){
        parent = new int[size];
        rank = new int[size];
        for(int i = 0; i < parent.length; i ++){
            parent[i] = i;
            rank[i] = 1;
        }
    }

    @Override
    public int getSize() {
        return parent.length;
    }

    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        //指向本身说明是根节点
        while(parent[p] != p){
            p = parent[p]; //如果不指向本身，就再去找父亲节点的父亲节点。
        }
        return p;
    }
    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
    @Override
    public void unionElements(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){ //如果最头头的父节点一样说明在一个集合了
            return;
        }
        if(rank[pRoot] < rank[qRoot]){
            parent[pRoot] = qRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
        }else if(rank[pRoot] > rank[qRoot]){
            parent[qRoot] = pRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
        }else{
            parent[qRoot] = pRoot;
            rank[pRoot] += 1;
        }

    }
}
```

#### 11.1.5 路径压缩

​	将路径压缩操作添加到find操作中。添加路径压缩之后，将树的深度逐渐变短。此时的rank不能再表示深度了，因为深度实际上是发生了变化的。所以，此时的rank不表示深度的意思了，表示的是等级。

```java
    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        //指向本身说明是根节点
        while(parent[p] != p){
            parent[p] = parent[parent[p]]; //路径压缩只需要加这一句
            p = parent[p]; //如果不指向本身，就再去找父亲节点的父亲节点。
        }
        return p;
    }
```

#### 11.1.6 路径压缩进一步优化

​	将路径压缩压缩成根节点下面的子节点都是直接指向根节点的样子。需要使用递归来实现。

```java
    // 从宏观上实现递归（这样就是把最头上的父节点的所有子节点在这一次全都指向了这个父节点了）
    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        if(p != parent[p]){
            parent[p] = find(parent[p]);
        }
        return parent[p];
    }
```

​	如果本次只是把本次查询的那个子节点指向最最头上的那个节点，其他的不变。应该就是下面这个实现。

```java
  //自己写的，不知道对不对
  private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        return pathCompression(p);
    }

    private int pathCompression(int p){
        // 已经到最头上的父节点了，不需要再继续压缩了
        if(parent[parent[p]] == parent[p]){
            return parent[p];
        }
        parent[p] = parent[parent[p]];
        return pathCompression(p);
    }
```

## 11.2 时间复杂度

​	添加了11.1.6的路径压缩后，时间复杂度可以达到O（log*n），这个和O（logn）是不一样的，比O（logn）更快，接近于O（1），又比O（1）慢一点的一种，因此算比较快的。

## 11.3 面试涉及

​	**很少**

## 11.4 力扣

> #### 题目：[由斜杠划分区域](https://leetcode-cn.com/problems/regions-cut-by-slashes/)
>
> 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。
>
> （请注意，反斜杠字符是转义的，因此 \ 用 "\\" 表示。）。
>
> 返回区域的数目。
>
>  
>
> 示例 1：
>
> 输入：
> [
>   " /",
>   "/ "
> ]
> 输出：2
> 解释：2x2 网格如下：
>
> 示例 2：
>
> 输入：
> [
>   " /",
>   "  "
> ]
> 输出：1
> 解释：2x2 网格如下：
>
> 示例 3：
>
> 输入：
> [
>   "\\/",
>   "/\\"
> ]
> 输出：4
> 解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）
> 2x2 网格如下：
>
> 示例 4：
>
> 输入：
> [
>   "/\\",
>   "\\/"
> ]
> 输出：5
> 解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）
> 2x2 网格如下：
>
> 示例 5：
>
> 输入：
> [
>   "//",
>   "/ "
> ]
> 输出：3
> 解释：2x2 网格如下：
>
>  
>
> 提示：
>
> 1 <= grid.length == grid[0].length <= 30
> grid[i][j] 是 '/'、'\'、或 ' '。

