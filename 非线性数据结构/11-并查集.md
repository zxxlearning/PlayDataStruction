## 11.1 并查集

​		并查集常会被用来解决**连接问题**。

​		定义并查集接口

```java
public interface UF {
    boolean isConnected(int p, int q);
    void unionElements(int p, int q);
}
```

#### 11.1.1 Quick Find

​	isConnected的时间复杂度是O（1），unionElements（就是进行合并的方法）的时间复杂度是O（n）,要遍历整个数组。如果一个算法的时间复杂度是O（n），就是说明这个算法是比较差的，是需要进行改进的。

```java
public class UnionFind1 implements UF{

    private int[] id;

    public UnionFind1(int size){
        id = new int[size];
        for(int i = 0; i < id.length; i ++){
            id[i] = i;
        }
    }

    @Override
    public int getSize() {
        return id.length;
    }

    private int find(int p){
        if(p < 0 || p > id.length){
            throw new IllegalArgumentException("Illegal index !");
        }
        return id[p];
    }

    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    @Override
    public void unionElements(int p, int q) {
        int idP = find(p);
        int idQ = find(q);
        if(idP == idQ){
            return;
        }
        for(int i = 0; i < id.length; i ++){
            if(id[i] == idP){
                id[i] = idQ;
            }
        }
    }
}
```

#### 11.1.2 Quick Union

​	相当于一个森林结构。底层结构用数组实现。查询和合并都是树的深度的时间复杂度。

```java
public class UnionFind2 implements UF {

    private int[] parent;

    public UnionFind2(int size){
        parent = new int[size];
        for(int i = 0; i < parent.length; i ++){
            parent[i] = i;
        }
    }

    @Override
    public int getSize() {
        return parent.length;
    }

    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        //指向本身说明是根节点
        while(parent[p] != p){
            p = parent[p]; //如果不指向本身，就再去找父亲节点的父亲节点。
        }
        return p;
    }
    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
    @Override
    public void unionElements(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){ //如果最头头的父节点一样说明在一个集合了
            return;
        }
        parent[pRoot] = qRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
    }
}
```

#### 11.1.3 根据size进行优化

合并的时候有一步是一个指向另一个的操作，如果随便指，长的指向短的时候，深度就会越来越深，时间复杂度就加大了，所以，在合并前判断一下，叫短的指向长的，这样就优化了树的深度。

```java
public class UnoinFind3 implements UF {

    private int[] parent;
    private int[] sz; // 表示以i为根的集合中元素的个数

    public UnoinFind3(int size){
        parent = new int[size];
        sz = new int[size];
        for(int i = 0; i < parent.length; i ++){
            parent[i] = i;
            sz[i] = 1;
        }
    }

    @Override
    public int getSize() {
        return parent.length;
    }

    private int find(int p){
        if(p < 0 || p > parent.length){
            throw new IllegalArgumentException("p is out of bound");
        }
        //指向本身说明是根节点
        while(parent[p] != p){
            p = parent[p]; //如果不指向本身，就再去找父亲节点的父亲节点。
        }
        return p;
    }
    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
    @Override
    public void unionElements(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == qRoot){ //如果最头头的父节点一样说明在一个集合了
            return;
        }
        if(sz[pRoot] < sz[qRoot]){
            parent[pRoot] = qRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
            sz[qRoot] += sz[pRoot];
        }else{
            parent[qRoot] = pRoot; //否则，就把其中一个的最头头父节点直接指向另一个的最头头父节点，就成了一个集合了。
            sz[pRoot] += sz[qRoot];
        }

    }
}
```

