## 6.1 二分搜索树

​	二分搜索树（Binary Search Tree）

#### 6.1.1 二叉树

​	二叉树和链表一样，是动态数据结构，每个结点的结构如下：

```java
class Node{ //分了两个叉，所以叫二叉树
    E e;
    Node left;
    Mode right;
}
```

​	二叉树有唯一的根节点，然后有一个左孩子和一个右孩子，最多只有两个孩子结点。对于没有孩子的结点，称为叶结点。叶子结点不一定是在最底层。每个结点最多有一个父亲。二叉树不一定是满的。一个单独结点也可以看做是二叉树，甚至一个空Null也可以看做是二叉树。（链表也是这样，一个结点或者Null都可以看做是链表）

​	二叉树具有天然的**递归结构**。树的这种递归结构更常用，链表是线性递归结构，一般可以用while循环代替。

​	每个二叉树根节点分别**在左右**又连接了一个更小的二叉树。

#### 6.1.2 二分搜索树

**性质：**

1. 二分搜索树是二叉树。
2. 二分搜索树每个节点的值都要大于其左子树的**所有结点**的值（所有结点，此时的左子树是指的以左孩子作为根节点的一个小的二叉树，这个小的二叉树的所有结点）；小于其右子树的所有结点的值。
3. 每一颗子树也是二叉搜索树。
4. 不一定是满的。
5. 存储的元素必须有可比较性。如果存储是自己的类，要保证类能根据某个属性进行比较。

#### 6.1.2 增加新元素

​	不包含重复元素。如果想包含相同元素，则在定义二叉搜索树时，使左子树**小于等于**节点，或右子树**大于等于**节点。

​	二分搜索树添加元素的非递归写法，和链表类似。

**非递归实现**（自己写的，不知道是不是还有更简洁的实现）

```java
    public void add(E e){
        if(root == null){ //空
            root = new Node(e, null, null);
            size ++;
            return;
        }
        //非空
        Node cur = root;

        while(cur != null){
            if(e.equals(cur.e)){
                return;
            }else if(e.compareTo(cur.e) < 0){
                if(cur.left == null){
                    cur.left = new Node(e, null, null);
                }
                cur = cur.left;
            }else{
                if(cur.right == null){
                    cur.right = new Node(e, null, null);
                }
                cur = cur.right;
            }
        }
        size ++;
    }
```

**递归实现**

```java
    /**
     * 添加元素，简略后的实现
     * @param e
     */
    public void add(E e){
        root = add(root, e);
    }
    private Node add(Node root, E e){
        //递归结束的条件
        if(root == null){
            size ++;
            return new Node(e, null, null);
        }

        //否则执行递归
        if(e.compareTo(e) < 0){
            root.left = add(root.left, e);
        }else if(e.compareTo(e) > 0){
            root.right = add(root.right, e);
        }

        return root;
    }
```

#### 

