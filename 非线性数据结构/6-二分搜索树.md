## 6.1 二分搜索树

​	二分搜索树（Binary Search Tree）

#### 6.1.1 二叉树

​	二叉树和链表一样，是动态数据结构，每个结点的结构如下：

```java
class Node{ //分了两个叉，所以叫二叉树
    E e;
    Node left;
    Mode right;
}
```

​	二叉树有唯一的根节点，然后有一个左孩子和一个右孩子，最多只有两个孩子结点。对于没有孩子的结点，称为叶结点。叶子结点不一定是在最底层。每个结点最多有一个父亲。二叉树不一定是满的。一个单独结点也可以看做是二叉树，甚至一个空Null也可以看做是二叉树。（链表也是这样，一个结点或者Null都可以看做是链表）

​	二叉树具有天然的**递归结构**。树的这种递归结构更常用，链表是线性递归结构，一般可以用while循环代替。

​	每个二叉树根节点分别**在左右**又连接了一个更小的二叉树。

#### 6.1.2 二分搜索树

**性质：**

1. 二分搜索树是二叉树。
2. 二分搜索树每个节点的值都要大于其左子树的**所有结点**的值（所有结点，此时的左子树是指的以左孩子作为根节点的一个小的二叉树，这个小的二叉树的所有结点）；小于其右子树的所有结点的值。
3. 每一颗子树也是二叉搜索树。
4. 不一定是满的。
5. 存储的元素必须有可比较性。如果存储是自己的类，要保证类能根据某个属性进行比较。

#### 6.1.2 增加新元素

​	不包含重复元素。如果想包含相同元素，则在定义二叉搜索树时，使左子树**小于等于**节点，或右子树**大于等于**节点。

​	二分搜索树添加元素的非递归写法，和链表类似。

**非递归实现**（自己写的，不知道是不是还有更简洁的实现）

```java
    public void add(E e){
        if(root == null){ //空
            root = new Node(e, null, null);
            size ++;
            return;
        }
        //非空
        Node cur = root;

        while(cur != null){
            if(e.equals(cur.e)){
                return;
            }else if(e.compareTo(cur.e) < 0){
                if(cur.left == null){
                    cur.left = new Node(e, null, null);
                }
                cur = cur.left;
            }else{
                if(cur.right == null){
                    cur.right = new Node(e, null, null);
                }
                cur = cur.right;
            }
        }
        size ++;
    }
```

**递归实现**

```java
    /**
     * 添加元素，简略后的实现
     * @param e
     */
    public void add(E e){
        root = add(root, e);
    }
    private Node add(Node root, E e){
        //递归结束的条件
        if(root == null){
            size ++;
            return new Node(e, null, null);
        }

        //否则执行递归
        if(e.compareTo(e) < 0){
            root.left = add(root.left, e);
        }else if(e.compareTo(e) > 0){
            root.right = add(root.right, e);
        }

        return root;
    }
```

#### 6.1.3 搜索某元素

**非递归实现**

```java
    public boolean contain(E e){
        if(isEmpty()){
            throw new IllegalArgumentException("the tree is empty!!");
        }
        Node cur = root;
        while(cur != null){
            if(e.compareTo(cur.e) == 0){
                return true;
            }else if(e.compareTo(cur.e) < 0){
                cur = cur.left;
            }else{
                cur = cur.right;
            }
        }
        return false;
    }
```

**递归实现**

```java
    public boolean contain(E e){
        return contain(root, e);
    }
    private boolean contain(Node node, E e){
        //递归结束条件
        if(node == null){
            return false;
        }

        //执行递归
        if(e.compareTo(node.e) == 0){
            return true;
        }else if(e.compareTo(node.e) < 0){
            return contain(node.left, e);
        }else{
            return contain(node.right, e);
        }
    }
```

## 6.2 二分搜索树的遍历

​	遍历就是把所有的节点都访问一遍。

​	二叉搜索树遍历的递归操作，需要注意两棵子树都要顾及到，前面的操作都是根据元素大小的判断选择操作某一侧的子树，而遍历的递归，是两棵子树都要执行遍历。

```java
//伪代码
function traverse(node):
	if(node == null)
        return;

	traverse(node.left)
    traverse(node.right)
```

### 深度优先遍历

#### 6.2.1 前序遍历

​	先访问根节点，再访问左右子树。

​	前序遍历是最自然、最常用的一种遍历方式，通常情况下都是采用前序遍历的方式。

**递归实现**

```java
    /**
     * 前序遍历
     */
    public void preOrder(){
        preOrder(root);
    }
    private void preOrder(Node root){
        if(root == null){
            return;
        }
        //执行遍历
        System.out.println(root.e);
        preOrder(root.left);
        preOrder(root.right);
    }
```

**非递归实现**（利用系统栈的原理，把下一次要用到的东西先暂存到系统栈，然后用到的时候取出）

```java
    /**
     * 前序遍历
     * 利用栈的结构
     */
    public void preOrder(){
        if(isEmpty()){
            return;
        }
        /**
         * 利用系统栈的原理
         *
         * 先把根节点存进去
         * 然后取出根节点，依次存入根节点的右结点和左结点
         * 然后此时栈顶元素是当前根节点的左孩子，也就是其左子树的根节点（若没有左孩子，则此时是右子树），取出该根节点，再依次存入该子树的右结点和左结点
         * 依次类推，直到栈为空，说明没有子树往里面存了，也就遍历结束了
         */
        Deque<Node> stack = new ArrayDeque<>();
        stack.push(root);
        while(!stack.isEmpty()){
            Node node = stack.pop();
            System.out.println(node.e);

            if(node.right != null)
                stack.push(node.right);
            if(node.left != null)
                stack.push(node.left);
        }
    }
```



#### 6.2.2 中序遍历

​	先访问结点的左子树，再访问根节点，再访问右子树。

```java
//伪代码
function traverse(node):
	if(node == null)
        return;
	traverse(node.left)
   	node
	traverse(node.right)
```
**递归实现**

```java
    /**
     * 中序遍历
     */
    public void inOrder(){
        inOrder(root);
    }
    private void inOrder(Node root){
        if(root == null){
            return;
        }
        //执行遍历
        inOrder(root.left);
        System.out.println(root.e);
        inOrder(root.right);
    }
```

中序遍历的非递归实现应用不多。

**非递归实现**

```java
    public void inOrder(){
        if(isEmpty()){
            return;
        }
        Deque<Node> stack = new ArrayDeque<>();
        Node head = root;
        while(! stack.isEmpty() || head != null){
            if(head != null){
                stack.push(head);
                head = head.left;
                continue;
            }
            head = stack.pop();
            System.out.println(head.e);
            head = head.right;
        }
    }
```

##### 应用

​	中序遍历的输出结果，就是对整个树中所有结点从小到大的输出。

#### 6.2.3 后序遍历

​	先访问结点的左子树，再访问结点的右子树，最后访问根节点。

**递归实现**

```java
    /**
     * 后序遍历
     */
    public void postOrder(){
        postOrder(root);
    }
    private void postOrder(Node root){
        if(root == null){
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.println(root.e);
    }
```

后序遍历的非递归实现应用不多。

**非递归实现**

```java
    /**
     * 后序遍历
     */
    public void postOrder(){
        if(isEmpty()){
            return;
        }
        Deque<Node> stack = new ArrayDeque<>();
        Node head = root;
        E preStackE = null;
        while(!stack.isEmpty() || head != null){

            /**
             * 先找左孩子再找右孩子
             * 先输出左孩子，在输出右孩子，最后输出根
             */
            //先找尽头的左孩子
            if(head != null){ //对于一个节点，不为空就去判断它的左孩子
                stack.push(head);
                head = head.left; //下一次就判断它的左结点
                continue;
            }

            // 此时的左结点为空，判断它的右兄弟
            /**
             * 如果当前结点的根节点的右结点为空 或者 当前结点的根节点的右结点为空等于上一次出栈的结点
             * 满足任一条件，将当前节点输出，并出栈。
             * 否则将右节点压栈。跳至第1步
             */
            Node nodeRoot = stack.peek();
            if(nodeRoot.right == null || nodeRoot.right.e.equals(preStackE)){
                preStackE = stack.pop().e;
                System.out.println(preStackE);
            }else{
                head = nodeRoot.right;
            }
        }
    }
```

##### 应用

​	内存的释放，要先释放孩子，在释放自己。Java中一般应用不到，因为有垃圾回收装置。C/C++中释放内存时就可以用二叉树的后序遍历实现。

### 广度优先遍历

#### 6.2.4 层次遍历

​	不好用递归实现了，要用非递归实现，用队列的结构实现。

**非递归实现**

```java
    /**
     * 层次遍历
     */
    public void levelOrder(){
        if(isEmpty()){
            return;
        }
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(root);
        while(! queue.isEmpty()){
            Node node = queue.poll(); //取出队首元素
            System.out.println(node.e);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
        }
    }
```



##### 应用

​	更快的得到问题的解

​	常用于算法设计中的----**无权图最短路径**

​	图中深度优先遍历和广度优先遍历

## 6.3 二分搜索树删除

#### 6.3.1 删除最小结点

```java
    /**
     * 删除最小结点
     * 最小的结点就是最左边的结点
     * 如果该结点是叶子结点，直接删除就可以了
     * 如果该结点有右孩子，则需要把右孩子接替自己原本的位置
     * @return
     */
    public E removeMin(){
        root = removeMin(root);
        return getMin().e;
    }
    private Node removeMin(Node root){
        if(root.left == null){ //递归结束条件
            Node res = root.right;
            root.right = null;
            size --;
            return res;
        }
        //执行递归
        root.left = removeMin(root.left);
        return root;
    }
```



#### 6.3.2 删除最大结点

```java
    /**
     * 删除最大结点
     * 最大的结点就是最右边的结点
     * 如果该结点是叶子结点，直接删除就可以了
     * 如果该结点有左孩子，则需要把左孩子接替自己原本的位置
     * @return
     */
    public E removeMax(){
        root = removeMax(root);
        return getMax().e;
    }
    private Node removeMax(Node root){
        if(root.right == null){ //递归结束条件
            Node res = root.left;
            root.left = null;
            size --;
            return res;
        }
        //执行递归
        root.right = removeMin(root.right);
        return root;
    }
```



#### 6.3.3 删除任意元素

```java
    /**
     * 删除指定结点
     * 被删除的结点：可能有左子树、可能有右子树、可能左右子树都在
     * 针对以上三种情况要分开处理
     * @param e
     */
    public void removeE(E e){
        root = removeE(root, e);
    }
    private Node removeE(Node root, E e){
        if(root == null){ //找到最后也没找到要删除的那个元素
            return null;
        }

        if(e.compareTo(root.e) < 0){ //要删的元素比当前元素小
            root.left = removeE(root.left, e);
            return root;
        }else if(e.compareTo(root.e) > 0){
            root.right = removeE(root.right, e); //右结点继续接上去
            return root;
        }else{ //找到了那个元素了，可以执行删除操作了

            //该结点有右孩子
            if(root.left == null){
                Node res = root.right;
                root.right = null;
                size --;
                return res;
            }
            //该结点有左孩子
            if(root.right == null){
                Node res = root.left;
                root.left = null;
                size --;
                return res;
            }
            //该结点左右孩子都有
            //可以找右子树的最小作为继承者，也可以找左子树的最大作为继承者
            Node sucessor = getMin(root.right);
            sucessor.right = removeMin(root.right);
            sucessor.left = root.left;

            root.left = null;
            root.right = null;

            return sucessor;
        }
    }
```



## 6.4 其他

​	二分搜索树具有顺序性

​	寻找floor和ceil（floor就是小于指定元素的最大值，ceil就是大于指定参数的最小值）

​	寻找rank和select（给Node增加size/depth）

​	支持重复元素的二叉树（给Node增加count）