## 6.1 二分搜索树

​	二分搜索树（Binary Search Tree）

#### 6.1.1 二叉树

​	二叉树和链表一样，是动态数据结构，每个结点的结构如下：

```java
class Node{ //分了两个叉，所以叫二叉树
    E e;
    Node left;
    Mode right;
}
```

​	二叉树有唯一的根节点，然后有一个左孩子和一个右孩子，最多只有两个孩子结点。对于没有孩子的结点，称为叶结点。叶子结点不一定是在最底层。每个结点最多有一个父亲。二叉树不一定是满的。一个单独结点也可以看做是二叉树，甚至一个空Null也可以看做是二叉树。（链表也是这样，一个结点或者Null都可以看做是链表）

​	二叉树具有天然的**递归结构**。树的这种递归结构更常用，链表是线性递归结构，一般可以用while循环代替。

​	每个二叉树根节点分别**在左右**又连接了一个更小的二叉树。

#### 6.1.2 二分搜索树

**性质：**

1. 二分搜索树是二叉树。
2. 二分搜索树每个节点的值都要大于其左子树的**所有结点**的值（所有结点，此时的左子树是指的以左孩子作为根节点的一个小的二叉树，这个小的二叉树的所有结点）；小于其右子树的所有结点的值。
3. 每一颗子树也是二叉搜索树。
4. 不一定是满的。
5. 存储的元素必须有可比较性。如果存储是自己的类，要保证类能根据某个属性进行比较。

#### 6.1.2 增加新元素

​	不包含重复元素。如果想包含相同元素，则在定义二叉搜索树时，使左子树**小于等于**节点，或右子树**大于等于**节点。

​	二分搜索树添加元素的非递归写法，和链表类似。

**非递归实现**（自己写的，不知道是不是还有更简洁的实现）

```java
    public void add(E e){
        if(root == null){ //空
            root = new Node(e, null, null);
            size ++;
            return;
        }
        //非空
        Node cur = root;

        while(cur != null){
            if(e.equals(cur.e)){
                return;
            }else if(e.compareTo(cur.e) < 0){
                if(cur.left == null){
                    cur.left = new Node(e, null, null);
                }
                cur = cur.left;
            }else{
                if(cur.right == null){
                    cur.right = new Node(e, null, null);
                }
                cur = cur.right;
            }
        }
        size ++;
    }
```

**递归实现**

```java
    /**
     * 添加元素，简略后的实现
     * @param e
     */
    public void add(E e){
        root = add(root, e);
    }
    private Node add(Node root, E e){
        //递归结束的条件
        if(root == null){
            size ++;
            return new Node(e, null, null);
        }

        //否则执行递归
        if(e.compareTo(e) < 0){
            root.left = add(root.left, e);
        }else if(e.compareTo(e) > 0){
            root.right = add(root.right, e);
        }

        return root;
    }
```

#### 6.1.3 搜索某元素

**非递归实现**

```java
    public boolean contain(E e){
        if(isEmpty()){
            throw new IllegalArgumentException("the tree is empty!!");
        }
        Node cur = root;
        while(cur != null){
            if(e.compareTo(cur.e) == 0){
                return true;
            }else if(e.compareTo(cur.e) < 0){
                cur = cur.left;
            }else{
                cur = cur.right;
            }
        }
        return false;
    }
```

**递归实现**

```java
    public boolean contain(E e){
        return contain(root, e);
    }
    private boolean contain(Node node, E e){
        //递归结束条件
        if(node == null){
            return false;
        }

        //执行递归
        if(e.compareTo(node.e) == 0){
            return true;
        }else if(e.compareTo(node.e) < 0){
            return contain(node.left, e);
        }else{
            return contain(node.right, e);
        }
    }
```

## 6.2 二分搜索树的遍历

​	遍历就是把所有的节点都访问一遍。

​	二叉搜索树遍历的递归操作，需要注意两棵子树都要顾及到，前面的操作都是根据元素大小的判断选择操作某一侧的子树，而遍历的递归，是两棵子树都要执行遍历。

```java
//伪代码
function traverse(node):
	if(node == null)
        return;

	traverse(node.left)
    traverse(node.right)
```

### 深度优先遍历

#### 6.2.1 前序遍历

​	先访问根节点，再访问左右子树。

​	前序遍历是最自然、最常用的一种遍历方式，通常情况下都是采用前序遍历的方式。

**递归实现**

```java
    /**
     * 前序遍历
     */
    public void preOrder(){
        preOrder(root);
    }
    private void preOrder(Node root){
        if(root == null){
            return;
        }
        //执行遍历
        System.out.println(root.e);
        preOrder(root.left);
        preOrder(root.right);
    }
```

**非递归实现**（利用系统栈的原理，把下一次要用到的东西先暂存到系统栈，然后用到的时候取出）

```java
    /**
     * 前序遍历
     * 利用栈的结构
     */
    public void preOrder(){
        if(isEmpty()){
            return;
        }
        /**
         * 利用系统栈的原理
         *
         * 先把根节点存进去
         * 然后取出根节点，依次存入根节点的右结点和左结点
         * 然后此时栈顶元素是当前根节点的左孩子，也就是其左子树的根节点（若没有左孩子，则此时是右子树），取出该根节点，再依次存入该子树的右结点和左结点
         * 依次类推，直到栈为空，说明没有子树往里面存了，也就遍历结束了
         */
        Deque<Node> stack = new ArrayDeque<>();
        stack.push(root);
        while(!stack.isEmpty()){
            Node node = stack.pop();
            System.out.println(node.e);

            if(node.right != null)
                stack.push(node.right);
            if(node.left != null)
                stack.push(node.left);
        }
    }
```



#### 6.2.2 中序遍历

​	先访问结点的左子树，再访问根节点，再访问右子树。

```java
//伪代码
function traverse(node):
	if(node == null)
        return;
	traverse(node.left)
   	node
	traverse(node.right)
```
**递归实现**

```java
    /**
     * 中序遍历
     */
    public void inOrder(){
        inOrder(root);
    }
    private void inOrder(Node root){
        if(root == null){
            return;
        }
        //执行遍历
        inOrder(root.left);
        System.out.println(root.e);
        inOrder(root.right);
    }
```

中序遍历的非递归实现应用不多。

##### 应用

​	中序遍历的输出结果，就是对整个树中所有结点从小到大的输出。

#### 6.2.3 后序遍历

​	先访问结点的左子树，再访问结点的右子树，最后访问根节点。

**递归实现**

```java
    /**
     * 后序遍历
     */
    public void postOrder(){
        postOrder(root);
    }
    private void postOrder(Node root){
        if(root == null){
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.println(root.e);
    }
```

后序遍历的非递归实现应用不多。

##### 应用

​	内存的释放，要先释放孩子，在释放自己。Java中一般应用不到，因为有垃圾回收装置。C/C++中释放内存时就可以用二叉树的后序遍历实现。

### 广度优先遍历

#### 6.2.4 层次遍历

​	不好用递归实现了，要用非递归实现，用队列的结构实现。

**非递归实现**

```java
    /**
     * 层次遍历
     */
    public void levelOrder(){
        if(isEmpty()){
            return;
        }
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(root);
        while(! queue.isEmpty()){
            Node node = queue.poll(); //取出队首元素
            System.out.println(node.e);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
        }
    }
```



##### 应用

​	更快的得到问题的解

​	常用于算法设计中的----**无权图最短路径**

​	图中深度优先遍历和广度优先遍历



