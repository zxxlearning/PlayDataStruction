	Set 和 Map是高层数据结构，相当于定义好这种结构，直接使用接口。

## 7.1 集合

​	Set 典型的特点就是去重。前面分析过的二分搜索树设定的是不能盛放重复元素，因此其就是非常好的实现“集合”的底层数据结构。

​	应用：客户统计

​		    词汇量统计

#### 7.1.1 集合接口

```java
Set<E>
 void add(E); //不能添加重复元素  
 void remove(E);
 boolean contains(E);
 int getSize();
 boolean isEmpty();
```

#### 7.1.2 二分搜索树作底层实现

```java
public class BSTSet< E extends Comparable<E> > implements Set<E> {

    BSTByDiGui<E> bst;

    BSTSet(){
        bst = new BSTByDiGui<>();
    }
    ...
```



#### 7.1.3 链表作底层实现

​	为什么也用链表作为集合类的底层实现呢，因为二分搜索树和链表都是动态数据结构，可以相应的比较这两种底层实现的效率实现。

```java
public class LinkedListSet<E extends Comparable<E>> implements Set<E> {

    private LinkedList<E> linkedList;

    LinkedListSet(){
        linkedList = new LinkedList<>();
    }
    ...
```



#### 7.1.4 复杂度分析

**计时的代码：**

```java
        //计时
        long startTime = System.nanoTime(); //得到的结果是纳秒
		...
        long endTime = System.nanoTime();
        double time = (endTime - startTime) / 1000000000.0; //纳秒到秒的转换
```

​	通过测试发现，基于二分搜索树的集合时间耗时不到1秒的时候，基于链表实现的要耗时5秒以上。因此**基于二分搜索树实现的效率更高**！

##### .1 基于链表时间复杂度

增 add    

​	因为链表没有设定不能添加重复元素，所以在对集合执行添加操作时，要先走一遍contain确定不含这个元素，才会执行添加；否则不执行操作。因此时间复杂度是**O（n）**。

查 contains     **O（n）**

删 remove       **O（n）**

##### .2 基于二叉搜索树时间复杂度

增 add    

​	因为二叉树设定了不能添加重复元素。因此时间复杂度是**O（h）** h是二叉树的深度

查 contains     **O（h）**

删 remove       **O（h）**

==平均情况下（满二叉树）：h = log2(n+1)  也就是O（h）≈ O（logn）==

| （以2为底） | logn |   n   |           |
| :---------: | :--: | :---: | :-------: |
|    n=16     |  4   |  16   |  相差4倍  |
|   n=1024    |  10  | 1024  | 相差100倍 |
|   n=100万   |  20  | 100万 | 相差5万倍 |

​	当二叉树是所有结点连成一侧树枝的情况，就相当于一个链表了，就会得到最差的时间复杂度O（n），为了解决这个问题，可以选用**平衡二叉树**。（==待补充==）



无序集合用哈希表做底层实现更好，即Java封装好的HashSet类