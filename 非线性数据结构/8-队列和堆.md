通过改变树的结构可以得到不同的数据结构类型：堆、线段树、字典树、并查集、AVL。

## 8.1 优先队列

普通队列：先进先出，后进后出。

优先队列：出队顺序和入队顺序无关，和优先级相关。

**为什么使用优先队列**

动态调用队列中优先级最高的，动态的原因是调用完一个之后，可能再进来优先级更高的，所以是动态的。

**优先队列接口**

```java
Interface Queue<E>
	void enqueue(E)
	E dequeue()
    E getFront()
    int getSize()
    boolean isEmpty()
```

优先队列可以使用不同的底层实现

|              | 入队 | 出队 |
| :----------: | :--: | :--: |
| 普通线性结构 | O(1) | O(n) |
| 顺序线性结构 | O(n) | O(1) |

可以看出上面两种线性结构的底层实现，效率都不是很好，都会出现O(n)的时间复杂度，本文使用==堆==做底层实现，可以大大提高效率。

|      |  入队   |  出队   |
| :--: | :-----: | :-----: |
|  堆  | O(logn) | O(logn) |

## 8.2 堆的基本结构

一般在数据结构中看到logn的时间复杂度，一般指的就是树的实现。

#### 8.2.1 二叉堆

​	二叉堆就是一颗完全二叉树，注意完全二叉树和满二叉树是不一样的，满二叉树就是满的树（除了叶子节点，其他节点的左右孩子都不为空），完全二叉树不一定是满的，不满的那一层一定是从左边开始接的。==二叉树和前面学习的二叉搜索树也是不一样的==。

##### .1 性质

1. 堆中某个节点的值总是不大于其父节点的值，这种叫最大堆。

2. 堆中父节点的值总是小于其孩子节点的值，这种叫最小堆。

##### .2 实现

**基本数据架构**

二叉堆可以用数组做底层实现，按照层依次存入数组中。

> 索引从0开始。设当前索引为i，则父节点的索引为（i-1）/2；左孩子的索引为（2 * i）+1；右孩子的索引为（2 * i）+2。

```java
    public int parent(int index){
        if(index == 0){
            throw new IllegalArgumentException("index 异常");
        }
        return (index - 1) / 2;
    }

    public int leftChild(int index){
        return (index * 2) + 1;
    }

    public int rightChild(int index){
        return (index * 2) + 2;
    }
```

**增加元素**

​	向堆中增加元素，就是继续从数组后面增加元素，在二叉堆上的显示就是如果本层还有空就继续向右填，如果本层没空了，开下一层，从左边开始往右添加。然后，因为二叉堆的特点（最大堆或最小堆），因此添加完一个元素之后，要比较该元素和父亲节点的大小，然后调整位置，然后再继续比较此时的父节点调整位置，一直比较当前的父节点，直到满足条件，这才完成了最终的添加操作。（这个过程可以看做堆元素的上浮）。

```java
    public void add(E e){
        //在数组尾部添加元素
        data.addLast(e);
        //调整新元素位置
        int cur_index = data.getSize() - 1;
        siftUp(cur_index);
    }
    private void siftUp(int cur_i){
        while(cur_i > 0 && data.get(parent(cur_i)).compareTo(data.get(cur_i)) < 0){
            swap(cur_i, parent(cur_i));
            cur_i = parent(cur_i);
        }
    }
    private void swap(int i, int j){
        if(i < 0 || i >= data.getSize() || j < 0 || j >= data.getSize())
            throw new IllegalArgumentException("Illegal!!");
        E temp = data.get(j);
        data.get(j) = data.get(i);
        data.get(i) = temp;
    }
```

**删除最大元素**

​	从堆中删除元素，就是删除最头上的那个节点（也就是数组的头个元素），删除完最头上的节点后，把余下的两个子树再拼接成一个树比较麻烦，因此直接把数组最后的那个元素提到头上来。然后和他的两个孩子作比较，调整位置，这个过程和增加元素的上浮类似，此处可以叫做下浮。

```java
    //看一下堆中的最大元素
    public E findMax(){
        if(data.getSize() == 0)
            throw new IllegalArgumentException("Illegal!!");
        return data.grt(0);
    }

    //取出堆中的最大元素
    public E extractMax(){
        E ret = findMax();
        swap(data.getSize()-1, 0);
        data.remove(data.getSize()-1); //最后这个元素要移出掉，因为已经转到头上去了
        siftDown(0);
        return ret;
    }
    private void siftDown(int cur_i){
        int l_i = leftChild(cur_i);
        int r_i = rightChild(cur_i);
        // 注意他可能有左孩子，但可能没有右孩子
        while(l_i < data.getSize()){
            int k = l_i;
            if(r_i < data.getSize()){
                k = data.get(l_i) > data.get(r_i) ? l_i : r_i;
            }
            if(data.get(k).compareTo(data.get(cur_i)) <= 0){
                break;
            }
            swap(cur_i, k);
            cur_i = k;
        }
    }
```

堆排序的实现，待补充.....

**取出最大元素，再加上一个元素**

```java
    public void replace(E e){
        // 直接改变最大值
        data.get(0) = e;
        // 然后执行下沉操作
        siftDown(0);
    }
```

**把一个数组转为二叉堆**

​	==关键点==：找到最后一个非叶子节点。根据二叉堆的数据结构特点，最后一个非叶子节点就是最后一个叶子节点的父节点。

```java
    // 以构造函数的方式实现，相当于传进来一个数组，然后构造成一个二叉堆
    public MaxHeap(E[] arr){
        data = arr; //这句是伪代码，意思就是把这个数组赋值给data了
        int len = arr.length;
        int k = parent(len - 1);
        while(k >= 0){
            siftDown(k);
            k --;
        }
    }
```

​	这样实现的时间复杂度是O(n)，如果把数组元素一个个的添加到二叉堆中去的话，时间复杂度是O(nlogn)。

## 8.3 优先队列

#### 8.3.1 使用堆实现优先队列

#### 8.3.2 基于优先队列的经典问题

​	在1,000,000个元素中如何额选出前100名元素，即在N个元素中选出前M个元素。

解决思路：

1.排序（最好的情况下，比如使用归并、快速排序，时间复杂度为NlogN），然后再取出前M个元素。

2.使用优先队列，可以在NlogM时间复杂度内解决。

**为什么是NlogM呢？**

​	使用优先队列，维护当前看到的前M个元素，（把M个元素放进优先队列中的时间复杂度为logM）,依次扫描剩下的元素，如果有比那M个元素大的，就替换掉，（此操作就相当于是出队操作，时间复杂度也是logM），最后总起来就是NlogM的时间复杂度了。

#### 8.3.3 Java中的PriorityQueue

​	import java.util.PriorityQueue 它的底层实现==默认是最小堆==。

常用方法

大小：size()

添加元素：add()

获取元素：peek()   此时相当于优先获取的是最小元素

移除元素：remove()

##### **. 力扣**：[前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
     /**   private class Freq implements Comparable<Freq>{
            public int e, fre;
            public Freq(int e, int fre){
                this.e = e;
                this.fre = fre;
            }
            @Override
            public int compareTo(Freq ano){
                if(this.fre < ano.fre){
                    return -1;
                }else if(this.fre > ano.fre){
                    return 1;
                }else{
                    return 0;
                }
            } 
        }
        **/
        /**
        //也可以自定义比较器
        private class FreqComparator implements Comparator<Freq>{
            @Override
            public int compare(Freq a, Freq b){
                return a.fre - b.fre;
            }
        }
        **/
        TreeMap<Integer, Integer> map = new TreeMap<>();
        for(int i = 0; i < nums.length; i ++){
            if(map.containsKey(nums[i])){
                map.put(nums[i], map.get(nums[i]) + 1);
            }else{
                map.put(nums[i], 1);
            }
        }
        List<Integer> list = new LinkedList<>();
        //用lamda表达式替换内部类
        /**
        PriorityQueue<Freq> queue = new PriorityQueue<>(new Comparator<Freq>(){
            @Override
            public int compare(Freq a, Freq b){
                return a.fre - b.fre;
            }
        });
        **/
        PriorityQueue<Integer> queue = new PriorityQueue<>(
            (a, b) -> map.get(a) - map.get(b)
        );
        for(int key : map.keySet()){
            if(queue.size() < k){
                queue.add(key);
            }else if(map.get(key) > map.get(queue.peek())){
                queue.remove();
                queue.add(key);
            }
        }
        while(!queue.isEmpty()){
            list.add(queue.remove());
        }
        return list;
    }
}
```

> 执行用时 :81 ms, 在所有 Java 提交中击败了29.13%的用户
>
> 内存消耗 :42.4 MB, 在所有 Java 提交中击败了87.36%的用户

用哈希表好像效率可以高一些，有待补充....

#### 8.3.4 堆的扩展和广义队列

​	二叉堆   可扩展为  D叉堆 （D就是有D个孩子）。它们有个共同的问题就是没有办法直接**看到/操作**中间堆元素，只能看到堆首的元素，因此，就需要一个新的数据结构叫==索引堆==的。（索引堆待补充）。最小生成树和最短路径都可以通过索引堆实现优化。在面试中不会有面试官考察索引堆，所以就了解一下就可以了。

​	二项堆  斐波那契堆

##### 广义队列

​	之前学习了普通队列、优先队列。甚至可以把栈看做一个队列。有时候一些问题的实现7只是区别用了什么数据结构，而不是逻辑。

