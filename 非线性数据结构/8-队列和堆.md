通过改变树的结构可以得到不同的数据结构类型：堆、线段树、字典树、并查集、AVL。

## 8.1 优先队列

普通队列：先进先出，后进后出。

优先队列：出队顺序和入队顺序无关，和优先级相关。

**为什么使用优先队列**

动态调用队列中优先级最高的，动态的原因是调用完一个之后，可能再进来优先级更高的，所以是动态的。

**优先队列接口**

```java
Interface Queue<E>
	void enqueue(E)
	E dequeue()
    E getFront()
    int getSize()
    boolean isEmpty()
```

优先队列可以使用不同的底层实现

|              | 入队 | 出队 |
| :----------: | :--: | :--: |
| 普通线性结构 | O(1) | O(n) |
| 顺序线性结构 | O(n) | O(1) |

可以看出上面两种线性结构的底层实现，效率都不是很好，都会出现O(n)的时间复杂度，本文使用==堆==做底层实现，可以大大提高效率。

|      |  入队   |  出队   |
| :--: | :-----: | :-----: |
|  堆  | O(logn) | O(logn) |

## 8.2 堆的基本结构

一般在数据结构中看到logn的时间复杂度，一般指的就是树的实现。

#### 8.2.1 二叉堆

​	二叉堆就是一颗完全二叉树，注意完全二叉树和满二叉树是不一样的，满二叉树就是满的树（除了叶子节点，其他节点的左右孩子都不为空），完全二叉树不一定是满的，不满的那一层一定是从左边开始接的。==二叉树和前面学习的二叉搜索树也是不一样的==。

##### .1 性质

1. 堆中某个节点的值总是不大于其父节点的值，这种叫最大堆。

2. 堆中父节点的值总是小于其孩子节点的值，这种叫最小堆。

##### .2 实现

**基本数据架构**

二叉堆可以用数组做底层实现，按照层依次存入数组中。

> 索引从0开始。设当前索引为i，则父节点的索引为（i-1）/2；左孩子的索引为（2 * i）+1；右孩子的索引为（2 * i）+2。

```java
    public int parent(int index){
        if(index == 0){
            throw new IllegalArgumentException("index 异常");
        }
        return (index - 1) / 2;
    }

    public int leftChild(int index){
        return (index * 2) + 1;
    }

    public int rightChild(int index){
        return (index * 2) + 2;
    }
```

**增加元素**

​	向堆中增加元素，就是继续从数组后面增加元素，在二叉堆上的显示就是如果本层还有空就继续向右填，如果本层没空了，开下一层，从左边开始往右添加。然后，因为二叉堆的特点（最大堆或最小堆），因此添加完一个元素之后，要比较该元素和父亲节点的大小，然后调整位置，然后再继续比较此时的父节点调整位置，一直比较当前的父节点，直到满足条件，这才完成了最终的添加操作。（这个过程可以看做堆元素的上浮）。

```java
    public void add(E e){
        //在数组尾部添加元素
        data.addLast(e);
        //调整新元素位置
        int cur_index = data.getSize() - 1;
        siftUp(cur_index);
    }
    private void siftUp(int cur_i){
        while(cur_i > 0 && data.get(parent(cur_i)).compareTo(data.get(cur_i)) < 0){
            swap(cur_i, parent(cur_i));
            cur_i = parent(cur_i);
        }
    }
    private void swap(int i, int j){
        if(i < 0 || i >= data.getSize() || j < 0 || j >= data.getSize())
            throw new IllegalArgumentException("Illegal!!");
        E temp = data.get(j);
        data.get(j) = data.get(i);
        data.get(i) = temp;
    }
```

**删除最大元素**

​	从堆中删除元素，就是删除最头上的那个节点（也就是数组的头个元素），删除完最头上的节点后，把余下的两个子树再拼接成一个树比较麻烦，因此直接把数组最后的那个元素提到头上来。然后和他的两个孩子作比较，调整位置，这个过程和增加元素的上浮类似，此处可以叫做下浮。

```java
    //看一下堆中的最大元素
    public E findMax(){
        if(data.getSize() == 0)
            throw new IllegalArgumentException("Illegal!!");
        return data.grt(0);
    }

    //取出堆中的最大元素
    public E extractMax(){
        E ret = findMax();
        swap(data.getSize()-1, 0);
        data.remove(data.getSize()-1); //最后这个元素要移出掉，因为已经转到头上去了
        siftDown(0);
        return ret;
    }
    private void siftDown(int cur_i){
        int l_i = leftChild(cur_i);
        int r_i = rightChild(cur_i);
        // 注意他可能有左孩子，但可能没有右孩子
        while(l_i < data.getSize()){
            int k = l_i;
            if(r_i < data.getSize()){
                k = data.get(l_i) > data.get(r_i) ? l_i : r_i;
            }
            if(data.get(k).compareTo(data.get(cur_i)) <= 0){
                break;
            }
            swap(cur_i, k);
            cur_i = k;
        }
    }
```

堆排序的实现，待补充.....

**取出最大元素，再加上一个元素**

```java
    public void replace(E e){
        // 直接改变最大值
        data.get(0) = e;
        // 然后执行下沉操作
        siftDown(0);
    }
```

**把一个数组转为二叉堆**

​	==关键点==：找到最后一个非叶子节点。根据二叉堆的数据结构特点，最后一个非叶子节点就是最后一个叶子节点的父节点。

```java
    // 以构造函数的方式实现，相当于传进来一个数组，然后构造成一个二叉堆
    public MaxHeap(E[] arr){
        data = arr; //这句是伪代码，意思就是把这个数组赋值给data了
        int len = arr.length;
        int k = parent(len - 1);
        while(k >= 0){
            siftDown(k);
            k --;
        }
    }
```

​	这样实现的时间复杂度是O(n)，如果把数组元素一个个的添加到二叉堆中去的话，时间复杂度是O(nlogn)。