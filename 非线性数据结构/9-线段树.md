线段树（Segment Tree）又叫区间树

## 9.1 线段树的基本结构

#### 9.1.1 为什么要使用线段树

​	对于有一类问题，我们关心的是线段（或者是区间）。

​	应用线段树的一个经典问题：区间染色

> ​                                             使用数组实现
>
> 染色操作（更新区间）             O(n)
>
> 查询操作（查询区间）             O(n)

​	另一类经典问题：区间查询。例如：查询某个区间内最大值，最小值，总量等。

#### 9.1.2 什么是线段树

​	线段树并不是完全二叉树，但是是平衡二叉树。**平衡二叉树**是最大深度-最小深度小于等于1，就是叶子节点所在的层数位置相差不超过1。（可以看出堆也是平衡二叉树，二叉搜索树并不一定是平衡二叉树，因为没有什么机制去保证层数相差不超过1）平衡二叉树是不会退化成为链表的，所以复杂度会维持在logn，用==平衡二叉树实现搜索是很高效==的。

​	线段树依旧可以用数组做底层实现，如果一个区间有n个元素，**用数组表示需要有多少节点**？

​	对于满二叉树：（从第0层表示）

> 满二叉树有h层，一共有2 ^h-1个节点（大约是2 ^h）
>
> 最后一层是h-1层，h-1层包含2 ^(h-1)个节点
>
> 最后一层的节点数**大致**等于前面所有层数的节点数和

​	如果n=2 ^k，此时的线段树是满二叉树，最后一层的节点数是2 ^k，则最后一层之前的所有层节点数和也大约是2 ^k，也就是需要给数组2n的空间。

​	如果n=2 ^k +1，若用满二叉树来存放（实际是存不满的），则还需要再增加一层，此时倒数第二层的节点数是2 ^k，即最后一层之前所有层节点和约为2n，最后一层的节点数也就等于2n，最后需要给数组分配4n的空间。

​	线段树不考虑添加元素，因此可以给数组定义更多的静态空间，用空间换时间。不考虑数组空间浪费情况，这样就可以用之前堆中学习的根据当前节点的索引可以快速得到父亲和孩子节点的索引。**若想避免空间浪费，就用链表代替数组做底层实现**。

```java
public class SegmentTree<E> {

    private E[] tree;
    private E[] data;

    public SegmentTree(E[] arr){
        data = (E[])new Objects[arr.length];
        for(int i = 0; i < arr.length; i ++){
            data[i] = arr[i];
        }
		//注意分配了4n的内存
        tree = (E[])new Objects[4 * arr.length];
    }

    public int getSize(){
        return data.length;
    }

    public E get(int index){
        if(index < 0 || index >= data.length)
            throw new IllegalArgumentException("Illegal!!");
        return data[index];
    }
    //返回左孩子索引
    private int leftChild(int index){
        return 2 * index + 1;
    }
    //返回右孩子索引
    private int rightChild(int index){
        return 2 * index + 2;
    }
```

